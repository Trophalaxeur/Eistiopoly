\section{R\'{e}f\'{e}rence du fichier monopoly.h}
\label{monopoly_8h}\index{monopoly.h@{monopoly.h}}
header du main 

\subsection*{Fonctions}
\begin{CompactItemize}
\item 
int {\bf main} (int argc, char $\ast$argv[$\,$])
\begin{CompactList}\small\item\em d\'{e}termine l'action \`{a} entreprendre en fonction du clic du joueur pendant le jeu \item\end{CompactList}\end{CompactItemize}


\subsection{Description d\'{e}taill\'{e}e}
header du main 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt Florian.lefevre@eisti.fr}$>$ \end{Desc}
\begin{Desc}
\item[Date:]09/01/2006 \end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}


D\'{e}finition dans le fichier {\bf monopoly.h}.

\subsection{Documentation des fonctions}
\index{monopoly.h@{monopoly.h}!main@{main}}
\index{main@{main}!monopoly.h@{monopoly.h}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int main (int {\em argc}, char $\ast$ {\em argv}[$\,$])}\label{monopoly_8h_0ddf1224851353fc92bfbff6f499fa97}


d\'{e}termine l'action \`{a} entreprendre en fonction du clic du joueur pendant le jeu 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt Florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em argc}]nombre d'argument lors du lancement du programme \item[{\em argv}]tableau des arguments lors du lancement du programme\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]0 \end{Desc}


D\'{e}finition \`{a} la ligne 13 du fichier monopoly.c.

\begin{Code}\begin{verbatim}14 {
15   information* bureau_de_krystel[16];
16   information* bureau_de_nadege[16];
17   
18   
19   //initialisation du random
20   srand(time(NULL));
21   
22   //ring de joueurs
23   joueur* j_anneau_joueurs;
24   j_anneau_joueurs=NULL;
25   
26   //ring de joueurs temporaire
27   joueur* pj_joueurs;
28   pj_joueurs=NULL;
29   
30   //Surface de l'écran
31   SDL_Surface* surf_ecran = NULL;
32   
33   int i;
34 
35   //Nombre de joueur
36   int nombre_joueur;
37   int int_nombre_joueur;
38 
39   int int_retour_config;
40   int int_retour_accueil;
41   int_retour_accueil=1;
42 
43   //Nom des joueurs
44   char** str_nom_joueur;
45   str_nom_joueur=NULL;
46 
47   //Tableau de couleur
48   rvb_couleur couleurs[8];
49   
50   //Plateau de jeu
51   cases** plateau;
52   
53   //Le plateau de jeu est composé de 40 pointeurs vers des instances de la structure cases
54   plateau=new cases*[40];
55   
56   //Chaque cases est un pointeur vers une instance de la structure case
57   for(i=0;i<40;i++)
58   {
59     plateau[i]=new cases;
60   }
61   
62   //Initialisation des couleurs
63   init_tab_rvb_couleur(couleurs);
64   
65   //Initialisation de sdl
66   surf_ecran=init_sdl();
67 
68   //Affichage de l'écran d'accueil
69   nombre_joueur=affich_accueil(surf_ecran);
70   if(nombre_joueur!=-1)
71   {
72     //S'il ne s'agit pas du chargement d'une partie
73     if(nombre_joueur!=-2)
74     {
75       nombre_joueur++;
76       //Allocation des joueurs
77       str_nom_joueur=new char*[nombre_joueur];
78       
79       //Initialisation du tableau
80       for(i=0;i<nombre_joueur;i++)
81       {
82         str_nom_joueur[i]=new char[16];
83         //Remplissage de la ligne avec des fins de ligne
84         memset(str_nom_joueur[i],(int)'\0',1);
85       }
86       //Affichage de l'écran de configuration
87       while((int_retour_config=affich_config(surf_ecran,str_nom_joueur,nombre_joueur))==-1 && int_retour_accueil)
88       {
89         //Libération des noms des joueurs
90         for(i=0;i<nombre_joueur;i++) 
91         {
92           delete(str_nom_joueur[i]);
93         }
94         delete(str_nom_joueur);
95         //Affichage de l'écran d'accueil
96         nombre_joueur=affich_accueil(surf_ecran);
97         if(nombre_joueur!=-1)
98         {
99           nombre_joueur++;
100           //Allocation des joueurs
101           str_nom_joueur=new char*[nombre_joueur];
102           //Initialisation du tableau
103           for(i=0;i<nombre_joueur;i++)
104           {
105             str_nom_joueur[i]=new char[16];;
106             //Remplissage du tableau avec des fins de ligne
107             memset(str_nom_joueur[i],(int)'\0',1);
108           }
109         }
110         else
111         {
112           int_retour_accueil=0;
113         }
114       }
115     }
116     //Si le jeu peut commencer
117     if((int_retour_config*int_retour_accueil)!=0 || nombre_joueur==-2)
118     {
119       //S'il ne s'agit pas d'un chargement
120       if(nombre_joueur!=-2)
121       {
122         //Initialisation des joueurs
123         j_anneau_joueurs=init_anneau_joueur(nombre_joueur, str_nom_joueur);
124 
125         //Initialisation du plateau
126         init_plateau(surf_ecran, couleurs, plateau);
127       }
128       //S'il s'agit d'un chargement
129       else
130       {
131         j_anneau_joueurs=chargement(j_anneau_joueurs, plateau, couleurs, surf_ecran);
132       }
133       //Initialisation du bureau de krystel et du bureau de Nadège
134       init_bureau_krystel(bureau_de_krystel);
135       init_bureau_nadege(bureau_de_nadege);
136       
137       pj_joueurs=j_anneau_joueurs;
138       int_nombre_joueur=1;
139       while((pj_joueurs=pj_joueurs->pjoueur_suivant)!=j_anneau_joueurs) int_nombre_joueur++;;
140       
141       //Lancement du jeu
142       jeu(surf_ecran, j_anneau_joueurs,plateau,int_nombre_joueur, bureau_de_krystel, bureau_de_nadege);
143     }
144   }
145   //On quitte le module SDL
146   SDL_Quit();
147   //On quitte le module TTF
148   TTF_Quit();
149   //Libération des cases du tableau
150   for(i=0;i<40;i++) delete(plateau[i]);
151   //Libération des noms des joueurs
152   if(nombre_joueur!=-2)
153   {
154     for(i=0;i<nombre_joueur;i++) delete(str_nom_joueur[i]);
155     delete(str_nom_joueur);
156   }
157   //Libération du plateau
158   delete(plateau);
159 
160   return (0);
161 }
\end{verbatim}\end{Code}


