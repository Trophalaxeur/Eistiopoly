\section{R\'{e}f\'{e}rence du fichier sdl.c}
\label{sdl_8c}\index{sdl.c@{sdl.c}}
\subsection*{Fonctions}
\begin{CompactItemize}
\item 
void {\bf mapause} (void)
\item 
SDL\_\-Surface $\ast$ {\bf rotation\_\-90} (SDL\_\-Surface $\ast$Depart)
\begin{CompactList}\small\item\em permet de tourner une image de 90 degr\~{A}© \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf rotation\_\-180} (SDL\_\-Surface $\ast$Depart)
\begin{CompactList}\small\item\em permet de tourner une image de 180 degr\~{A}© \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf rotation\_\-270} (SDL\_\-Surface $\ast$Depart)
\begin{CompactList}\small\item\em permet de tourner une image de 270 degr\~{A}© \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf init\_\-sdl} (void)
\begin{CompactList}\small\item\em fonction d'initialisation de sdl \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-joueur} (int int\_\-joueur)
\begin{CompactList}\small\item\em cr\~{A}©er la surface du joueur \item\end{CompactList}\item 
void {\bf affich\_\-joueur} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf joueur} $\ast$pj\_\-joueur, int int\_\-position, {\bf cases} $\ast$pcase)
\begin{CompactList}\small\item\em affiche un joueur \~{A}  l'\~{A}©cran \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf rvb\_\-couleur} couleur, char $\ast$texte1, char $\ast$texte2, int int\_\-prix, int int\_\-position)
\begin{CompactList}\small\item\em cr\~{A}©er une case de type salle \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-bureau} (SDL\_\-Surface $\ast$ecran, int int\_\-type, int int\_\-position)
\begin{CompactList}\small\item\em cr\~{A}©er une case de type bureau \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-lieu\_\-commun} (SDL\_\-Surface $\ast$ecran, int int\_\-type)
\begin{CompactList}\small\item\em cr\~{A}©er une case de type lieu commun \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-association} (SDL\_\-Surface $\ast$ecran, int int\_\-type)
\begin{CompactList}\small\item\em cr\~{A}©er une case de type association \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-soiree} (SDL\_\-Surface $\ast$ecran, int int\_\-type)
\begin{CompactList}\small\item\em cr\~{A}©er une case de type soir\~{A}©e \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-coin} (SDL\_\-Surface $\ast$ecran, int int\_\-type)
\begin{CompactList}\small\item\em cr\~{A}©er une case sp\~{A}©cial (chacun des coins) \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-detail} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf rvb\_\-couleur} couleur, char $\ast$texte, int int\_\-prix, int int\_\-prix\_\-niveau)
\begin{CompactList}\small\item\em cr\~{A}©er la surface de la case d\~{A}©taill\~{A}© \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-detail\_\-lc} (SDL\_\-Surface $\ast$surf\_\-ecran, int int\_\-type)
\begin{CompactList}\small\item\em cr\~{A}©er la surface de la case d\~{A}©taille d'une case lieu commun \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-detail\_\-assoc} (SDL\_\-Surface $\ast$surf\_\-ecran, int int\_\-type)
\begin{CompactList}\small\item\em cr\~{A}©er la surface de la case d\~{A}©taille d'une case association \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-case\_\-propriete} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf rvb\_\-couleur} couleur, char $\ast$texte)
\begin{CompactList}\small\item\em cr\~{A}©er la surface de la propri\~{A}©t\~{A}© qui s'affichera dans le panneau des propri\~{A}©t\~{A}©s \item\end{CompactList}\item 
int {\bf affich\_\-accueil} (SDL\_\-Surface $\ast$surf\_\-ecran)
\begin{CompactList}\small\item\em affiche la page d'accueil \item\end{CompactList}\item 
int {\bf affich\_\-config} (SDL\_\-Surface $\ast$surf\_\-ecran, char $\ast$$\ast$str\_\-nom\_\-joueur, int nombre\_\-joueur)
\begin{CompactList}\small\item\em affiche la page de configuration de la partie \item\end{CompactList}\item 
void {\bf affich\_\-case} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf cases} $\ast$pcase)
\begin{CompactList}\small\item\em affiche une case \~{A}  l'\~{A}©cran \item\end{CompactList}\item 
void {\bf affich\_\-case\_\-detail} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf cases} $\ast$pcase)
\begin{CompactList}\small\item\em affiche le d\~{A}©tail d'une case \item\end{CompactList}\item 
void {\bf affich\_\-centre} (SDL\_\-Surface $\ast$surf\_\-ecran, SDL\_\-Surface $\ast$surf\_\-centre)
\begin{CompactList}\small\item\em affiche le centre du plateau \item\end{CompactList}\item 
void {\bf affich\_\-panneau\_\-menu} (SDL\_\-Surface $\ast$surf\_\-ecran, int int\_\-etat\_\-bouton)
\begin{CompactList}\small\item\em affiche le panneau du menu \item\end{CompactList}\item 
void {\bf affich\_\-panneau\_\-joueur} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf joueur} $\ast$j\_\-anneau\_\-joueurs)
\begin{CompactList}\small\item\em affiche le panneau d'information sur le joueur \item\end{CompactList}\item 
void {\bf affich\_\-panneau\_\-possessions} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf joueur} $\ast$j\_\-anneau\_\-joueurs)
\begin{CompactList}\small\item\em affiche le panneau des possessions du joueur \item\end{CompactList}\item 
void {\bf affich\_\-possessions\_\-cache} (SDL\_\-Surface $\ast$surf\_\-ecran)
\begin{CompactList}\small\item\em affiche le cache du panneau de possesion du joueur \item\end{CompactList}\item 
void {\bf affich\_\-panneau\_\-des\_\-bouton} (SDL\_\-Surface $\ast$surf\_\-ecran, int int\_\-image)
\begin{CompactList}\small\item\em affiche le panneau contenant le bouton lancer d\~{A}© \item\end{CompactList}\item 
SDL\_\-Surface $\ast$$\ast$ {\bf creation\_\-des} (void)
\begin{CompactList}\small\item\em renvoit un tableau de surface contenant chacune des faces du d\~{A}© \item\end{CompactList}\item 
void {\bf destruction\_\-des} (SDL\_\-Surface $\ast$$\ast$surf\_\-des)
\begin{CompactList}\small\item\em d\~{A}©truit les surfaces des d\~{A}©s \item\end{CompactList}\item 
void {\bf affich\_\-panneau\_\-fdt} (SDL\_\-Surface $\ast$surf\_\-ecran, bool bool\_\-etat)
\begin{CompactList}\small\item\em affiche le panneau du menu \item\end{CompactList}\item 
void {\bf affich\_\-panneau\_\-des} (SDL\_\-Surface $\ast$surf\_\-ecran, SDL\_\-Surface $\ast$$\ast$surf\_\-des, int int\_\-de1, int int\_\-de2)
\begin{CompactList}\small\item\em affiche le panneau du menu \item\end{CompactList}\item 
void {\bf affich\_\-joueur\_\-depart} (SDL\_\-Surface $\ast$surf\_\-ecran, {\bf cases} $\ast$$\ast$plateau, {\bf joueur} $\ast$j\_\-anneau\_\-joueurs, int nombre\_\-joueur)
\begin{CompactList}\small\item\em affiche tout les joueurs sur la case de d\~{A}©part \item\end{CompactList}\item 
int {\bf affich\_\-validation\_\-propriete} (SDL\_\-Surface $\ast$surf\_\-ecran, SDL\_\-Surface $\ast$surf\_\-fond, int int\_\-etat, int int\_\-nombre\_\-boutons,...)
\begin{CompactList}\small\item\em affiche le message des propri\~{A}©t\~{A}© ainsi que les boutons d'actions possibles \item\end{CompactList}\item 
SDL\_\-Surface $\ast$ {\bf creation\_\-message} (SDL\_\-Surface $\ast$surf\_\-ecran, char $\ast$titre, char $\ast$$\ast$message, int int\_\-type\_\-message, int int\_\-nbre\_\-ligne)
\begin{CompactList}\small\item\em cr\~{A}©er la surface d'un message \~{A}  afficher \item\end{CompactList}\item 
void {\bf affich\_\-message} (SDL\_\-Surface $\ast$surf\_\-ecran, SDL\_\-Surface $\ast$surf\_\-message, int int\_\-type\_\-message, int int\_\-etat)
\begin{CompactList}\small\item\em affiche un message \~{A}  l'\~{A}©cran \item\end{CompactList}\end{CompactItemize}


\subsection{Documentation des fonctions}
\index{sdl.c@{sdl.c}!mapause@{mapause}}
\index{mapause@{mapause}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void mapause (void)}\label{sdl_8c_9f152afdc94602d80bba17d28ed09046}




D\'{e}finition \`{a} la ligne 4 du fichier sdl.c.

\begin{Code}\begin{verbatim}5 {
6     int continuer = 1;
7     SDL_Event event;
8     while (continuer)
9     {
10         SDL_WaitEvent(&event);
11         switch(event.type)
12         {
13             case SDL_QUIT:
14                 continuer = 0;
15         break;
16       case SDL_KEYDOWN:
17         switch(event.key.keysym.sym)
18         {
19           case SDLK_ESCAPE:
20             continuer = 0;
21             break;
22           default:
23           break;
24         }
25         break;
26       default:
27       break;
28         }
29     }
30 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!rotation_90@{rotation\_\-90}}
\index{rotation_90@{rotation\_\-90}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ rotation\_\-90 (SDL\_\-Surface $\ast$ {\em Depart})}\label{sdl_8c_41ae5df3ce6489fa50c29d6661e93cd5}


permet de tourner une image de 90 degr\~{A}© 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em Depart}]surface de d\~{A}©part\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface tourn\~{A}©e \end{Desc}


D\'{e}finition \`{a} la ligne 32 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par affich\_\-case(), creation\_\-case(), creation\_\-case\_\-bureau(), creation\_\-case\_\-lieu\_\-commun(), et creation\_\-case\_\-soiree().

\begin{Code}\begin{verbatim}33 {
34   //La surface d'arrivee
35   SDL_Surface* arrivee;
36   arrivee = SDL_CreateRGBSurface(SDL_HWSURFACE,Depart->h,Depart->w,Depart->format->BitsPerPixel,0,0,0,0);
37   
38   int x;
39   int y;
40 
41   for(y=0;y<Depart->h;y+=1)
42   {
43     for(x=0;x<Depart->w;x+=1)
44     {
45       ((Uint32*)arrivee->pixels)[y+((arrivee->h-1)-x)*arrivee->w]=((Uint32*)Depart->pixels)[x+y*Depart->w];
46     }
47   }
48   return(arrivee);
49 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!rotation_180@{rotation\_\-180}}
\index{rotation_180@{rotation\_\-180}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ rotation\_\-180 (SDL\_\-Surface $\ast$ {\em Depart})}\label{sdl_8c_65fe10ba88741bea209745d655b54643}


permet de tourner une image de 180 degr\~{A}© 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em Depart}]surface de d\~{A}©part\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface tourn\~{A}©e \end{Desc}


D\'{e}finition \`{a} la ligne 51 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par affich\_\-case(), creation\_\-case(), creation\_\-case\_\-association(), creation\_\-case\_\-bureau(), et creation\_\-case\_\-lieu\_\-commun().

\begin{Code}\begin{verbatim}52 {
53   // La surface d'arrivee
54   SDL_Surface* arrivee;
55   arrivee = SDL_CreateRGBSurface(SDL_HWSURFACE,Depart->w,Depart->h,Depart->format->BitsPerPixel,0,0,0,0);
56   
57   int x;
58   int y;
59   for(y=0;y<Depart->h;y+=1)
60   {
61     for(x=0;x<Depart->w;x+=1)
62     {
63       ((Uint32*)arrivee->pixels)[((arrivee->w-1)-x)+((arrivee->h-1)-y)*arrivee->w]=((Uint32*)Depart->pixels)[x+y*Depart->w];
64     }
65   }
66   return(arrivee);
67 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!rotation_270@{rotation\_\-270}}
\index{rotation_270@{rotation\_\-270}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ rotation\_\-270 (SDL\_\-Surface $\ast$ {\em Depart})}\label{sdl_8c_5b67a4a6911f4af317483eab10d4b6d1}


permet de tourner une image de 270 degr\~{A}© 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em Depart}]surface de d\~{A}©part\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface tourn\~{A}©e \end{Desc}


D\'{e}finition \`{a} la ligne 69 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par affich\_\-case(), creation\_\-case(), creation\_\-case\_\-association(), creation\_\-case\_\-bureau(), et creation\_\-case\_\-lieu\_\-commun().

\begin{Code}\begin{verbatim}70 {
71   // La surface d'arrivee
72   SDL_Surface* arrivee;
73   arrivee = SDL_CreateRGBSurface(SDL_HWSURFACE,Depart->h,Depart->w,Depart->format->BitsPerPixel,0,0,0,0);
74   
75   int x,y;
76   for(y=0;y<Depart->h;y+=1)
77   {
78     for(x=0;x<Depart->w;x+=1)
79     {
80       ((Uint32*)arrivee->pixels)[((arrivee->w-1)-y)+x*arrivee->w]=((Uint32*)Depart->pixels)[x+y*Depart->w];
81     }
82   }
83   return(arrivee);
84 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!init_sdl@{init\_\-sdl}}
\index{init_sdl@{init\_\-sdl}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ init\_\-sdl (void)}\label{sdl_8c_78d639dbac5f322d56cb30e265664e5b}


fonction d'initialisation de sdl 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de l'\~{A}©cran \end{Desc}


D\'{e}finition \`{a} la ligne 86 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par main().

\begin{Code}\begin{verbatim}87 {
88   //Surface de l'ecran
89   SDL_Surface *ecran=NULL;
90 
91   //Initialisation en mode video de sdl
92   SDL_Init(SDL_INIT_VIDEO);
93   
94   //Répétition des touches
95   SDL_EnableKeyRepeat(80,80);
96 
97   //Initialisation du mode TTF (Pour l'ecriture)
98   TTF_Init();
99   
100   //Chargement du mode video en resolution 800*600 et 32 couleur, plein ecran.
101   ecran = SDL_SetVideoMode(1280, 1024, 32, SDL_HWSURFACE|SDL_FULLSCREEN);
102   
103   //Chargement du titre de la fenetre
104   SDL_WM_SetCaption("Monopoly", NULL);
105   
106   //On remplit le fond de noir
107   SDL_FillRect(ecran, NULL, SDL_MapRGB(ecran->format, 25, 25, 75));
108   
109   //On retourne la surface de l'écran
110   return(ecran);
111 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_joueur@{creation\_\-joueur}}
\index{creation_joueur@{creation\_\-joueur}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-joueur (int {\em int\_\-joueur})}\label{sdl_8c_abe95d6657aa550ae767eadca6df4b8c}


cr\~{A}©er la surface du joueur 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em int\_\-joueur}]num\~{A}©ro du joueur\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface du joueur \end{Desc}


D\'{e}finition \`{a} la ligne 113 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-joueur(), et init\_\-joueur\_\-chargement().

\begin{Code}\begin{verbatim}114 {
115   //Surface du joueur
116   SDL_Surface* surf_joueur;
117   surf_joueur=NULL;
118   //Chemin d'accès à l'image
119   char chemin[256];
120   
121   //Stockage du chemin vers l'image du joueur en fonction de son numéro
122   sprintf(chemin,"sdl/images/joueur%d.png",int_joueur);
123   
124   //Chargement de l'image
125   surf_joueur=IMG_Load(chemin);
126   
127   //On retourne l'image du joueur
128   return(surf_joueur);
129   
130 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_joueur@{affich\_\-joueur}}
\index{affich_joueur@{affich\_\-joueur}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-joueur (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf joueur} $\ast$ {\em pj\_\-joueur}, int {\em int\_\-position}, {\bf cases} $\ast$ {\em pcase})}\label{sdl_8c_6b7f77ae67e59ddecb20065c14b04efe}


affiche un joueur \~{A}  l'\~{A}©cran 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em pj\_\-joueur}]joueur en cours \item[{\em int\_\-position}]position du joueur sur la case \item[{\em pcase}]case sur laquelle se trouve le joueur\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 132 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par affich\_\-joueur\_\-depart(), aller\_\-a\_\-jeton(), aller\_\-en\_\-prison\_\-jeton(), attente\_\-validation\_\-propriete(), avancer\_\-jeton(), et reculer\_\-jeton().

\begin{Code}\begin{verbatim}133 {
134   //Position du joueur
135   SDL_Rect position;
136   
137   //Selon la position de la case
138   switch((*pcase).int_position)
139   {
140     //On calcul les coordonnées de l'image du joueur
141     case POSITION_GAUCHE:
142       position.x=(*pcase).rect_coordonnees.x+25+30*(int_position%2);
143       position.y=(*pcase).rect_coordonnees.y+5+25*(int_position%3);
144       break;
145     case POSITION_DROITE:
146       position.x=(*pcase).rect_coordonnees.x+35+30*(int_position%2);
147       position.y=(*pcase).rect_coordonnees.y+5+25*(int_position%3);
148       break;
149     case POSITION_HAUT:
150       position.x=(*pcase).rect_coordonnees.x+5+25*(int_position%3);
151       position.y=(*pcase).rect_coordonnees.y+25+30*(int_position%2);
152       break;
153     default:
154       position.x=(*pcase).rect_coordonnees.x+5+25*(int_position%3);
155       position.y=(*pcase).rect_coordonnees.y+35+30*(int_position%2);
156       break;
157   }
158   //On colle l'image du joueur sur le fond
159   SDL_BlitSurface(pj_joueur->surf_image, NULL, surf_ecran, &position);
160   //On met à jour l'écran
161   SDL_Flip(surf_ecran);
162 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case@{creation\_\-case}}
\index{creation_case@{creation\_\-case}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf rvb\_\-couleur} {\em couleur}, char $\ast$ {\em texte1}, char $\ast$ {\em texte2}, int {\em int\_\-prix}, int {\em int\_\-position})}\label{sdl_8c_8c3a2f7bbcb5b7dba8411f9e37e1bbcb}


cr\~{A}©er une case de type salle 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em couleur}]couleur du groupe \item[{\em texte1}]premi\~{A}¨re partie du nom de la case \item[{\em texte2}]seconde partie du nom de la case \item[{\em int\_\-prix}]prix de la case \item[{\em int\_\-position}]cot\~{A}© sur lequel se trouve la case\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case \end{Desc}


D\'{e}finition \`{a} la ligne 164 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-salle().

\begin{Code}\begin{verbatim}165 {
166   //Chaine de caractere du prix
167   char texte_prix[255];
168 
169   //Surface de la case
170   SDL_Surface* surf_case;
171   surf_case=NULL;
172 
173   //Surface du fond de la case
174   SDL_Surface* surf_fond;
175   surf_fond=NULL;
176 
177   //Surface de la couleur du groupe
178   SDL_Surface* surf_groupe;
179   surf_groupe=NULL;
180 
181   //Surface du fond du groupe
182   SDL_Surface* surf_fond_groupe;
183   surf_fond_groupe=NULL;
184 
185   //Surface du texte partie 1
186   SDL_Surface* surf_texte1;
187   surf_texte1=NULL;
188 
189   //Surface du texte partie 2
190   SDL_Surface* surf_texte2;
191   surf_texte2=NULL;
192 
193   //Surface du texte partie 2
194   SDL_Surface* surf_texte_prix;
195   surf_texte_prix=NULL;
196 
197   //Police d'écriture
198   TTF_Font* police;
199   police=NULL;
200 
201   //Couleur du texte
202   SDL_Color couleur_texte = {0, 0, 0};
203   //Couleur du fond du texte
204   SDL_Color couleur_fond_texte = {16, 246, 128};
205 
206   //Position
207   SDL_Rect position;
208   
209   //Ouverture de la police d'ecriture
210   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 14);
211 
212   //Ecriture de la première partie du texte
213   surf_texte1 = TTF_RenderText_Shaded(police, texte1, couleur_texte, couleur_fond_texte);
214   //Ecriture de la seconde partie du texte
215   surf_texte2 = TTF_RenderText_Shaded(police, texte2, couleur_texte, couleur_fond_texte);
216   //Enregistrement du prix
217   sprintf(texte_prix,"%d Fintz",int_prix);
218   //Ecriture du prix
219   surf_texte_prix = TTF_RenderText_Shaded(police, texte_prix, couleur_texte, couleur_fond_texte);
220 
221   //Fermeture de la police d'ecriture
222   TTF_CloseFont(police);
223 
224   //Création de la surface de la case
225   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
226   //Remplissage de noir pour faire le cadre
227   SDL_FillRect(surf_case, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
228 
229   //Création de la surface de fond
230   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR-2*CASE_EPAISSEUR, CASE_HAUTEUR-2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
231   //Remplissage de vert tapis
232   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 16, 246, 128));
233 
234   //Création de la surface du groupe
235   surf_groupe=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_GROUPE_HAUTEUR+2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
236   //Remplissage de noir pour faire le cadre
237   SDL_FillRect(surf_groupe, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
238 
239   //Création de la surface de fond du groupe
240   surf_fond_groupe=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR-2*CASE_EPAISSEUR, CASE_GROUPE_HAUTEUR, 32, 0, 0, 0, 0);
241   //Remplissage de la couleur de fond du groupe
242   SDL_FillRect(surf_fond_groupe, NULL, SDL_MapRGB(surf_ecran->format, couleur.rouge, couleur.vert, couleur.bleu));
243 
244   //On modifie la position du fond du groupe
245   position.x=CASE_EPAISSEUR;
246   position.y=CASE_EPAISSEUR;
247   //On colle le fond du groupe sur ce dernier
248   SDL_BlitSurface(surf_fond_groupe, NULL, surf_groupe, &position);
249 
250   //On modifie la position du fond
251   position.x=CASE_EPAISSEUR;
252   position.y=CASE_EPAISSEUR;
253   //On colle le fond sur la case
254   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
255 
256   //On modifie la position du groupe
257   position.x=0;
258   position.y=0;
259   //On colle le groupe sur la case
260   SDL_BlitSurface(surf_groupe, NULL, surf_case, &position);
261 
262   //On centre la position de la premiere partie texte
263   position.x=(CASE_LARGEUR-(*surf_texte1).w)/2;
264   position.y=30;
265   //On colle la première partie du texte
266   SDL_BlitSurface(surf_texte1, NULL, surf_case, &position);
267 
268   //On centre la position de la deuxieme partie du texte
269   position.x=(CASE_LARGEUR-(*surf_texte2).w)/2;
270   position.y=50;
271   //On colle la deuxième partie du texte
272   SDL_BlitSurface(surf_texte2, NULL, surf_case, &position);
273 
274   //On centre la position du prix
275   position.x=(CASE_LARGEUR-(*surf_texte_prix).w)/2;
276   position.y=CASE_HAUTEUR-CASE_EPAISSEUR-20;
277   //On colle le prix
278   SDL_BlitSurface(surf_texte_prix, NULL, surf_case, &position);
279   
280   //Selon la position
281   switch(int_position)
282   {
283     //Si la case est à droite
284     case POSITION_DROITE:
285       //Rotation de l'image de 90°
286       surf_case = rotation_90(surf_case);
287       break;
288     //Si la case est en haut
289     case POSITION_HAUT:
290       //Rotation de l'image de 180°
291       surf_case = rotation_180(surf_case);
292       break;
293     //Si la case est à gauche
294     case POSITION_GAUCHE:
295       //Rotation de l'image de 270°
296       surf_case = rotation_270(surf_case);
297       break;
298     //Par défaut, la case est en bas
299     default:
300     break;
301   }
302   
303   //Libération des surfaces temporaires
304   SDL_FreeSurface(surf_fond);
305   SDL_FreeSurface(surf_fond_groupe);
306   SDL_FreeSurface(surf_groupe);
307   SDL_FreeSurface(surf_texte1);
308   SDL_FreeSurface(surf_texte2);
309   SDL_FreeSurface(surf_texte_prix);
310 
311   //On retourne la surface de la case
312   return(surf_case);
313 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_bureau@{creation\_\-case\_\-bureau}}
\index{creation_case_bureau@{creation\_\-case\_\-bureau}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-bureau (SDL\_\-Surface $\ast$ {\em ecran}, int {\em int\_\-type}, int {\em int\_\-position})}\label{sdl_8c_3a24261fa9d00f3a59e56774538f6f4c}


cr\~{A}©er une case de type bureau 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type de bureau \item[{\em int\_\-position}]c\~{A}´t\~{A}© sur lequel se trouve la case\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case \end{Desc}


D\'{e}finition \`{a} la ligne 315 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-administration().

\begin{Code}\begin{verbatim}316 {
317   //Surface du logo
318   SDL_Surface* surf_logo;
319   surf_logo=NULL;
320   //Surface du fond de la case
321   SDL_Surface* surf_fond;
322   surf_fond=NULL;
323   //Surface de la case
324   SDL_Surface* surf_case;
325   surf_case=NULL;
326   //Surface de la première partie du texte
327   SDL_Surface* surf_texte1;
328   surf_texte1=NULL;
329   //Surface de la deuxième partie du texte
330   SDL_Surface* surf_texte2;
331   surf_texte2=NULL;
332   //Position des images
333   SDL_Rect position;
334 
335   //Police d'écriture
336   TTF_Font* police;
337   police=NULL;
338 
339   //Couleur du texte
340   SDL_Color couleur_texte = {0, 0, 0};
341   //Couleur du fond du texte
342   SDL_Color couleur_fond_texte = {16, 246, 128};
343 
344   //Ouvertue de la police d'écriture
345   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 14);
346   
347   //Ecriture du premier texte
348   surf_texte1 = TTF_RenderText_Shaded(police, "Bureau de", couleur_texte, couleur_fond_texte);
349   //Ecriture du second texte
350   if(int_type==BUREAU_KRYSTEL) surf_texte2 = TTF_RenderText_Shaded(police, "Krystel", couleur_texte, couleur_fond_texte);
351   else surf_texte2 = TTF_RenderText_Shaded(police, "Nadege", couleur_texte, couleur_fond_texte);
352 
353   //Fermeture de la police d'écriture
354   TTF_CloseFont(police);
355 
356   //Création de la surface de la case
357   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
358   //Remplissage de noir pour faire le cadre
359   SDL_FillRect(surf_case, NULL, SDL_MapRGB(ecran->format, 0, 0, 0));
360 
361   //Création de la surface de fond
362   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR-2*CASE_EPAISSEUR, CASE_HAUTEUR-2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
363   //Remplissage de vert tapis
364   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(ecran->format, 16, 246, 128));
365 
366   //Chargelent de l'image du logo
367   if(int_type==BUREAU_KRYSTEL) surf_logo = IMG_Load("sdl/images/eisti_logo.png");
368   else surf_logo = IMG_Load("sdl/images/eisti_logo2.png");
369 
370   //On modifie la position du fond
371   position.x=CASE_EPAISSEUR;
372   position.y=CASE_EPAISSEUR;
373   //On colle le fond sur la case
374   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
375 
376   //On centre la position de la première partie texte
377   position.x=(CASE_LARGEUR-(*surf_texte1).w)/2;
378   position.y=5;
379   //On colle la première partie du texte
380   SDL_BlitSurface(surf_texte1, NULL, surf_case, &position);
381 
382   //On centre la position de la deuxième partie du texte
383   position.x=(CASE_LARGEUR-(*surf_texte2).w)/2;
384   position.y=25;
385   //On colle la deuxième partie du texte
386   SDL_BlitSurface(surf_texte2, NULL, surf_case, &position);
387 
388   //On positione le logo
389   position.x=16;
390   position.y=45;
391   //On colle le logo sur la case
392   SDL_BlitSurface(surf_logo, NULL, surf_case, &position);
393 
394   //Selon la position
395   switch(int_position)
396   {
397     //Si la case est à droite
398     case POSITION_DROITE:
399       //Rotation de l'image de 90°
400       surf_case = rotation_90(surf_case);
401       break;
402     //Si la case est en haut
403     case POSITION_HAUT:
404       //Rotation de l'image de 180°
405       surf_case = rotation_180(surf_case);
406       break;
407     //Si la case est à gauche
408     case POSITION_GAUCHE:
409       //Rotation de l'image de 270°
410       surf_case = rotation_270(surf_case);
411       break;
412     //Par défaut, la case est en bas
413     default:
414     break;
415   }
416 
417   //Libération des surfaces temporaires
418   SDL_FreeSurface(surf_fond);
419   SDL_FreeSurface(surf_logo);
420   SDL_FreeSurface(surf_texte1);
421   SDL_FreeSurface(surf_texte2);
422   //On retourne la case que l'on vient de créer
423   return(surf_case);
424 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_lieu_commun@{creation\_\-case\_\-lieu\_\-commun}}
\index{creation_case_lieu_commun@{creation\_\-case\_\-lieu\_\-commun}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-lieu\_\-commun (SDL\_\-Surface $\ast$ {\em ecran}, int {\em int\_\-type})}\label{sdl_8c_e8bdf28f1ee03bd77a52246f2a968a05}


cr\~{A}©er une case de type lieu commun 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type de lieu commun\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case \end{Desc}


D\'{e}finition \`{a} la ligne 426 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-lieu\_\-commun().

\begin{Code}\begin{verbatim}427 {
428   //Surface de l'image
429   SDL_Surface* surf_image;
430   surf_image=NULL;
431   //Surface du fond de la case
432   SDL_Surface* surf_fond;
433   surf_fond=NULL;
434   //Surface de la case
435   SDL_Surface* surf_case;
436   surf_case=NULL;
437   //Surface du prix
438   SDL_Surface* surf_prix;
439   surf_prix=NULL;
440 
441   //Position des images
442   SDL_Rect position;
443 
444   //Police d'écriture
445   TTF_Font* police;
446   police=NULL;
447 
448   //Couleur du texte
449   SDL_Color couleur_texte = {0, 0, 0};
450   //Couleur du fond du texte
451   SDL_Color couleur_fond_texte = {16, 246, 128};
452 
453   //Ouvertue de la police d'écriture
454   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 14);
455   
456   //Ecriture du premier texte
457   surf_prix = TTF_RenderText_Shaded(police, "2000 Fintz", couleur_texte, couleur_fond_texte);
458 
459   //Fermeture de la police d'écriture
460   TTF_CloseFont(police);
461 
462   //Création de la surface de la case
463   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
464   //Remplissage de noir pour faire le cadre
465   SDL_FillRect(surf_case, NULL, SDL_MapRGB(ecran->format, 0, 0, 0));
466 
467   //Création de la surface de fond
468   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR-2*CASE_EPAISSEUR, CASE_HAUTEUR-2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
469   //Remplissage de vert tapis
470   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(ecran->format, 16, 246, 128));
471 
472   //Chargement de l'image
473   //if(int_type==BDE) surf_image = IMG_Load("sdl/images/bureau_bde.png");
474   switch(int_type)
475   {
476     case LC_WC:
477       surf_image = IMG_Load("sdl/images/wc.png");
478       break;
479     case LC_ASCENSEUR:
480       surf_image = IMG_Load("sdl/images/ascenseur.png");
481       break;
482     case LC_RU:
483       surf_image = IMG_Load("sdl/images/ru.png");
484       break;
485     case LC_PARKING:
486       surf_image = IMG_Load("sdl/images/parking.png");
487       break;
488     default:
489       break;
490   }
491   //On modifie la position du fond
492   position.x=CASE_EPAISSEUR;
493   position.y=CASE_EPAISSEUR;
494   //On colle le fond sur la case
495   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
496 
497   //On positionne le prix
498   position.x=(CASE_LARGEUR-(*surf_prix).w)/2;
499   position.y=CASE_HAUTEUR-CASE_EPAISSEUR-20;
500   //On colle le prix sur la case
501   SDL_BlitSurface(surf_prix, NULL, surf_case, &position);
502 
503   //On positione le logo
504   position.x=10;
505   position.y=8;
506   //On colle le logo sur la case
507   SDL_BlitSurface(surf_image, NULL, surf_case, &position);
508 
509   //Selon la position
510   switch(int_type)
511   {
512     //Si la case est à droite
513     case LC_PARKING:
514       //Rotation de l'image de 90°
515       surf_case = rotation_90(surf_case);
516       break;
517     //Si la case est en haut
518     case LC_RU:
519       //Rotation de l'image de 180°
520       surf_case = rotation_180(surf_case);
521       break;
522     //Si la case est à gauche
523     case LC_ASCENSEUR:
524       //Rotation de l'image de 270°
525       surf_case = rotation_270(surf_case);
526       break;
527     //Par défaut, la case est en bas
528     default:
529     break;
530   }
531 
532   //Libération des surfaces temporaires
533   SDL_FreeSurface(surf_fond);
534   SDL_FreeSurface(surf_image);
535   SDL_FreeSurface(surf_prix);
536 
537   //On retourne la case que l'on vient de créer
538   return(surf_case);
539 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_association@{creation\_\-case\_\-association}}
\index{creation_case_association@{creation\_\-case\_\-association}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-association (SDL\_\-Surface $\ast$ {\em ecran}, int {\em int\_\-type})}\label{sdl_8c_69fe209fbdca57ab6d23403d6e88f27f}


cr\~{A}©er une case de type association 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type de l'association\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case \end{Desc}


D\'{e}finition \`{a} la ligne 540 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-association().

\begin{Code}\begin{verbatim}541 {
542   //Surface du logo
543   SDL_Surface* surf_logo;
544   surf_logo=NULL;
545   //Surface du fond de la case
546   SDL_Surface* surf_fond;
547   surf_fond=NULL;
548   //Surface de la case
549   SDL_Surface* surf_case;
550   surf_case=NULL;
551   //Surface du prix
552   SDL_Surface* surf_prix;
553   surf_prix=NULL;
554 
555   //Position des images
556   SDL_Rect position;
557 
558   //Police d'écriture
559   TTF_Font* police;
560   police=NULL;
561 
562   //Couleur du texte
563   SDL_Color couleur_texte = {0, 0, 0};
564   //Couleur du fond du texte
565   SDL_Color couleur_fond_texte = {16, 246, 128};
566 
567   //Ouvertue de la police d'écriture
568   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 14);
569   
570   //Ecriture du premier texte
571   surf_prix = TTF_RenderText_Shaded(police, "1500 Fintz", couleur_texte, couleur_fond_texte);
572 
573   //Fermeture de la police d'écriture
574   TTF_CloseFont(police);
575 
576   //Création de la surface de la case
577   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
578   //Remplissage de noir pour faire le cadre
579   SDL_FillRect(surf_case, NULL, SDL_MapRGB(ecran->format, 0, 0, 0));
580 
581   //Création de la surface de fond
582   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR-2*CASE_EPAISSEUR, CASE_HAUTEUR-2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
583   //Remplissage de vert tapis
584   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(ecran->format, 16, 246, 128));
585 
586   //Chargelent de l'image du logo
587   if(int_type==BDE) surf_logo = IMG_Load("sdl/images/bureau_bde.png");
588   else surf_logo = IMG_Load("sdl/images/bureau_bds.png");
589 
590   //On modifie la position du fond
591   position.x=CASE_EPAISSEUR;
592   position.y=CASE_EPAISSEUR;
593   //On colle le fond sur la case
594   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
595 
596   //On positionne le prix
597   position.x=(CASE_LARGEUR-(*surf_prix).w)/2;
598   position.y=CASE_HAUTEUR-CASE_EPAISSEUR-20;
599   //On colle le prix sur la case
600   SDL_BlitSurface(surf_prix, NULL, surf_case, &position);
601 
602   //On positione le logo
603   position.x=10;
604   position.y=8;
605   //On colle le logo sur la case
606   SDL_BlitSurface(surf_logo, NULL, surf_case, &position);
607 
608   //Selon le type de bureau d'association
609   switch(int_type)
610   {
611     //S'il s'agit du bde
612     case BDE:
613       //Rotation de l'image de 180
614       surf_case = rotation_180(surf_case);
615       break;
616     //Par défaut, il s'agit du bds
617     default:
618       //Rotation de l'image de 270°
619       surf_case = rotation_270(surf_case);
620       break;
621     break;
622   }
623 
624   //Libération des surfaces temporaires
625   SDL_FreeSurface(surf_fond);
626   SDL_FreeSurface(surf_logo);
627   SDL_FreeSurface(surf_prix);
628 
629   //On retourne la case que l'on vient de créer
630   return(surf_case);
631 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_soiree@{creation\_\-case\_\-soiree}}
\index{creation_case_soiree@{creation\_\-case\_\-soiree}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-soiree (SDL\_\-Surface $\ast$ {\em ecran}, int {\em int\_\-type})}\label{sdl_8c_59f59937f8c57e3bee2ce4a391aaf5f1}


cr\~{A}©er une case de type soir\~{A}©e 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type de la soir\~{A}©e\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case \end{Desc}


D\'{e}finition \`{a} la ligne 633 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-soiree().

\begin{Code}\begin{verbatim}634 {
635   //Surface du logo
636   SDL_Surface* surf_logo;
637   surf_logo=NULL;
638   //Surface du fond de la case
639   SDL_Surface* surf_fond;
640   surf_fond=NULL;
641   //Surface de la case
642   SDL_Surface* surf_case;
643   surf_case=NULL;
644   //Surface du prix
645   SDL_Surface* surf_prix;
646   surf_prix=NULL;
647   SDL_Surface* surf_texte;
648   surf_texte=NULL;
649 
650   //Position des images
651   SDL_Rect position;
652 
653   //Police d'écriture
654   TTF_Font* police;
655   police=NULL;
656 
657   //Couleur du texte
658   SDL_Color couleur_texte = {0, 0, 0};
659   //Couleur du fond du texte
660   SDL_Color couleur_fond_texte = {16, 246, 128};
661 
662   //Ouvertue de la police d'écriture
663   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 14);
664   
665   //Ecriture du premier texte
666   if(int_type==SOIREE_AREA) surf_texte = TTF_RenderText_Shaded(police, "Area club", couleur_texte, couleur_fond_texte);
667   else surf_texte = TTF_RenderText_Shaded(police, "Gala", couleur_texte, couleur_fond_texte);
668   //Ecriture du premier texte
669   surf_prix = TTF_RenderText_Shaded(police, "1500 Fintz", couleur_texte, couleur_fond_texte);
670 
671   //Fermeture de la police d'écriture
672   TTF_CloseFont(police);
673 
674   //Création de la surface de la case
675   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
676   //Remplissage de noir pour faire le cadre
677   SDL_FillRect(surf_case, NULL, SDL_MapRGB(ecran->format, 0, 0, 0));
678 
679   //Création de la surface de fond
680   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR-2*CASE_EPAISSEUR, CASE_HAUTEUR-2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
681   //Remplissage de vert tapis
682   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(ecran->format, 16, 246, 128));
683 
684   //Chargelent de l'image du logo
685   if(int_type==SOIREE_AREA) surf_logo = IMG_Load("sdl/images/soiree_area.png");
686   else surf_logo = IMG_Load("sdl/images/soiree_gala.png");
687 
688   //On modifie la position du fond
689   position.x=CASE_EPAISSEUR;
690   position.y=CASE_EPAISSEUR;
691   //On colle le fond sur la case
692   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
693 
694   //On positionne le prix
695   position.x=(CASE_LARGEUR-(*surf_texte).w)/2;
696   position.y=CASE_HAUTEUR-CASE_EPAISSEUR-40;
697   //On colle le prix sur la case
698   SDL_BlitSurface(surf_texte, NULL, surf_case, &position);
699 
700   //On positionne le prix
701   position.x=(CASE_LARGEUR-(*surf_prix).w)/2;
702   position.y=CASE_HAUTEUR-CASE_EPAISSEUR-20;
703   //On colle le prix sur la case
704   SDL_BlitSurface(surf_prix, NULL, surf_case, &position);
705 
706   //On positione le logo
707   position.x=10;
708   position.y=8;
709   //On colle le logo sur la case
710   SDL_BlitSurface(surf_logo, NULL, surf_case, &position);
711 
712   //S'il s'agit du gala
713   if(int_type==SOIREE_GALA)
714   {
715     //Rotation de l'image de 90°
716     surf_case = rotation_90(surf_case);
717   }
718 
719   //Libération des surfaces temporaires
720   SDL_FreeSurface(surf_fond);
721   SDL_FreeSurface(surf_logo);
722   SDL_FreeSurface(surf_prix);
723   SDL_FreeSurface(surf_texte);
724 
725   //On retourne la case que l'on vient de créer
726   return(surf_case);
727 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_coin@{creation\_\-case\_\-coin}}
\index{creation_case_coin@{creation\_\-case\_\-coin}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-coin (SDL\_\-Surface $\ast$ {\em ecran}, int {\em int\_\-type})}\label{sdl_8c_862ad6aa9409faa0fa6128712013d727}


cr\~{A}©er une case sp\~{A}©cial (chacun des coins) 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type de la case\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case \end{Desc}


D\'{e}finition \`{a} la ligne 729 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-special().

\begin{Code}\begin{verbatim}730 {
731   //Surface de l'image
732   SDL_Surface* surf_image;
733   surf_image=NULL;
734   //Surface du fond de la case
735   SDL_Surface* surf_fond;
736   surf_fond=NULL;
737   //Surface de la case
738   SDL_Surface* surf_case;
739   surf_case=NULL;
740 
741   //Position des images
742   SDL_Rect position;
743 
744   //Création de la surface de la case
745   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_HAUTEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
746   //Remplissage de noir pour faire le cadre
747   SDL_FillRect(surf_case, NULL, SDL_MapRGB(ecran->format, 0, 0, 0));
748 
749   //Création de la surface de fond
750   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_HAUTEUR-2*CASE_EPAISSEUR, CASE_HAUTEUR-2*CASE_EPAISSEUR, 32, 0, 0, 0, 0);
751   //Remplissage de vert tapis
752   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(ecran->format, 16, 246, 128));
753 
754   //Chargelent de l'image du logo
755   switch(int_type)
756   {
757     case SP_APPARTEMENT:
758       surf_image = IMG_Load("sdl/images/case_depart.png");
759       break;
760     case SP_BUREAU_LAURENCE:
761       surf_image = IMG_Load("sdl/images/bureau_laurence.png");
762       break;
763     case SP_MACHINE_CAFE:
764       surf_image = IMG_Load("sdl/images/machine_cafe.png");
765       break;
766     case SP_TABLEAU:
767       surf_image = IMG_Load("sdl/images/go_to_prison.png");
768       break;
769   }
770 
771   //On modifie la position du fond
772   position.x=CASE_EPAISSEUR;
773   position.y=CASE_EPAISSEUR;
774   //On colle le fond sur la case
775   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
776 
777   //On positionne l'image sur le fond
778   position.x=CASE_EPAISSEUR;
779   position.y=CASE_EPAISSEUR;
780   //On colle le logo sur la case
781   SDL_BlitSurface(surf_image, NULL, surf_case, &position);
782 
783   //Libération des surfaces temporaires
784   SDL_FreeSurface(surf_fond);
785   SDL_FreeSurface(surf_image);
786 
787   //On retourne la case que l'on vient de créer
788   return(surf_case);
789 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_detail@{creation\_\-case\_\-detail}}
\index{creation_case_detail@{creation\_\-case\_\-detail}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-detail (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf rvb\_\-couleur} {\em couleur}, char $\ast$ {\em texte}, int {\em int\_\-prix}, int {\em int\_\-prix\_\-niveau})}\label{sdl_8c_8265ad0c4ff5c2310c05f5b55b6db199}


cr\~{A}©er la surface de la case d\~{A}©taill\~{A}© 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em couleur}]couleur du groupe de la case \item[{\em texte}]nom de la case \item[{\em int\_\-prix}]prix de la case \item[{\em int\_\-prix\_\-niveau}]prix d'un niveau de la case\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case d\~{A}©taill\~{A}© \end{Desc}


D\'{e}finition \`{a} la ligne 791 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-salle().

\begin{Code}\begin{verbatim}792 {
793   SDL_Surface* surf_case;
794   surf_case=NULL;
795   SDL_Surface* surf_fond;
796   surf_fond=NULL;
797   SDL_Surface* surf_groupe;
798   surf_groupe=NULL;
799   SDL_Surface* surf_groupe_fond;
800   surf_groupe_fond=NULL;
801   SDL_Surface* surf_sep;
802   surf_sep=NULL;
803   SDL_Surface* surf_texte[22];
804   char texte_temp[256];
805   int i;
806   
807   //Police d'écriture
808   TTF_Font* police;
809   police=NULL;
810 
811   //Couleur du texte
812   SDL_Color couleur_texte = {0, 0, 0};
813   //Couleur du fond du texte
814   SDL_Color couleur_fond_texte = {225, 255, 225};
815   //Couleur du groupe
816   SDL_Color couleur_groupe = {couleur.rouge, couleur.vert, couleur.bleu};
817 
818   //Position
819   SDL_Rect position;
820   
821   //Ouverture de la police d'ecriture
822   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 28);
823 
824   //Tire de la carte de propriété
825   surf_texte[1] = TTF_RenderText_Shaded(police, texte, couleur_texte, couleur_groupe);
826 
827   //Fermeture de la police d'ecriture
828   TTF_CloseFont(police);
829     
830   //Ouverture de la police d'ecriture
831   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 20);
832   
833   //Ecriture des informations contenus dans le groupe
834   surf_texte[0] = TTF_RenderText_Shaded(police, "Titre de propriété", couleur_texte, couleur_groupe);
835   
836   //Ecriture des textes sur les informations sur les loyers
837   surf_texte[2] = TTF_RenderText_Shaded(police, "LOYER Salle vide", couleur_texte, couleur_fond_texte);
838   surf_texte[3] = TTF_RenderText_Shaded(police, "Niveau CPI 1", couleur_texte, couleur_fond_texte);
839   surf_texte[4] = TTF_RenderText_Shaded(police, "Niveau CPI 2", couleur_texte, couleur_fond_texte);
840   surf_texte[5] = TTF_RenderText_Shaded(police, "Niveau ING 1", couleur_texte, couleur_fond_texte);
841   surf_texte[6] = TTF_RenderText_Shaded(police, "Niveau ING 2", couleur_texte, couleur_fond_texte);
842   surf_texte[7] = TTF_RenderText_Shaded(police, "Niveau ING 3", couleur_texte, couleur_fond_texte);
843   
844   //Ecriture de la monnaie utilisé
845   surf_texte[8] = TTF_RenderText_Shaded(police, "Fintz", couleur_texte, couleur_fond_texte);
846   
847   //Ecriture des différents prix
848   for(i=0;i<6;i++)
849   {
850     sprintf(texte_temp,"%d",int_prix*(i+1));
851     surf_texte[9+i] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
852   }
853   
854   //Fermeture de la police d'ecriture
855   TTF_CloseFont(police);
856   
857   //Ouverture de la police d'ecriture
858   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
859   
860   //Ecriture des informations sur les loyers
861   surf_texte[15] = TTF_RenderText_Shaded(police, "Si un élève possède toutes les salles", couleur_texte, couleur_fond_texte);
862   surf_texte[16] = TTF_RenderText_Shaded(police, "d'un groupe de couleur, le loyer des", couleur_texte, couleur_fond_texte);
863   surf_texte[17] = TTF_RenderText_Shaded(police, "salles vides de ce groupe est doublé.", couleur_texte, couleur_fond_texte);
864   
865   //Ecriture des informations sur l'achat d'un niveau et l'hypothèque
866   sprintf(texte_temp,"Prix d'un niveau                    %d Fintz",int_prix_niveau);
867   surf_texte[18] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
868   surf_texte[19] = TTF_RenderText_Shaded(police, "chacun", couleur_texte, couleur_fond_texte);
869   surf_texte[20] = TTF_RenderText_Shaded(police, "Valeur Hypothécaire de la salle", couleur_texte, couleur_fond_texte);
870   sprintf(texte_temp,"%d Fintz",int_prix);
871   surf_texte[21] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
872   
873   //Fermeture de la police d'ecriture
874   TTF_CloseFont(police);
875 
876   //Création de la surface de la case
877   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR, DETAIL_HAUTEUR, 32, 0, 0, 0, 0);
878   //Remplissage de noir pour faire le cadre
879   SDL_FillRect(surf_case, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
880 
881   //Création de la surface de fond
882   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR-2*DETAIL_EPAISSEUR, DETAIL_HAUTEUR-2*DETAIL_EPAISSEUR, 32, 0, 0, 0, 0);
883   //Remplissage de vert tapis
884   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 225, 255, 225));
885 
886   //Création de la surface du groupe
887   surf_groupe=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR, DETAIL_GROUPE_HAUTEUR+2*DETAIL_EPAISSEUR, 32, 0, 0, 0, 0);
888   //Remplissage de noir pour faire le cadre
889   SDL_FillRect(surf_groupe, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
890 
891   //Création de la surface du groupe
892   surf_groupe_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR-2*DETAIL_EPAISSEUR, DETAIL_GROUPE_HAUTEUR, 32, 0, 0, 0, 0);
893   //Remplissage de la couleur du groupe
894   SDL_FillRect(surf_groupe_fond, NULL, SDL_MapRGB(surf_ecran->format, couleur.rouge, couleur.vert, couleur.bleu));
895 
896   //Création de la surface de séparation
897   surf_sep=SDL_CreateRGBSurface(SDL_HWSURFACE, (DETAIL_LARGEUR*9)/10, 3, 32, 0, 0, 0, 0);
898   //Remplissage de noir
899   SDL_FillRect(surf_sep, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
900 
901   //On modifie la position du fond
902   position.x=DETAIL_EPAISSEUR;
903   position.y=DETAIL_EPAISSEUR;
904   //On colle le fond du groupe sur ce dernier
905   SDL_BlitSurface(surf_groupe_fond, NULL, surf_groupe, &position);
906 
907   //On modifie la position du fond
908   position.x=DETAIL_EPAISSEUR;
909   position.y=DETAIL_EPAISSEUR;
910   //On colle le fond sur la case
911   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
912 
913   //On modifie la position du fond
914   position.x=0;
915   position.y=0;
916   //On colle le groupe sur la case
917   SDL_BlitSurface(surf_groupe, NULL, surf_case, &position);
918 
919   //Pour le texte contenu dans la coulerur du groupe
920   for(i=0;i<2;i++)
921   {
922     //On centre la position du texte
923     position.x=(DETAIL_LARGEUR-(*surf_texte[i]).w)/2;
924     position.y=10+25*i;
925     //On colle le texte sur la surface
926     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
927   }
928 
929   //Modification de la position du texte pour le loyer du terrain nu
930   position.x=20;
931   position.y=105;
932   //Affichage du loyer du terrain nu
933   SDL_BlitSurface(surf_texte[2], NULL, surf_case, &position);
934   
935   //Pour les autres informations de la carte
936   for(i=3;i<8;i++)
937   {
938     //On centre la position du texte
939     position.x=95;
940     position.y=55+25*i;
941     //On colle le texte sur la surface
942     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
943   }
944 
945   //Pour les informations sur les prix
946   for(i=8;i<15;i++)
947   {
948     //On centre la position du texte
949     position.x=DETAIL_LARGEUR-15-(surf_texte[i]->w);
950     position.y=55+25*(i-7);
951     //On colle le texte sur la surface
952     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
953   }
954 
955   //Position du séparateur de texte
956   position.x=DETAIL_LARGEUR/20;
957   position.y=262;
958   //Affichage du séparateur de texte
959   SDL_BlitSurface(surf_sep, NULL, surf_case, &position);
960   
961   for(i=15;i<18;i++)
962   {
963     //On centre la position du texte
964     position.x=(DETAIL_LARGEUR-(*surf_texte[i]).w)/2;
965     position.y=90+20*(i-6);
966     //On colle le texte sur la surface
967     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
968   }
969 
970   //Position du séparateur de texte
971   position.x=DETAIL_LARGEUR/20;
972   position.y=337;
973   //Affichage du séparateur de texte
974   SDL_BlitSurface(surf_sep, NULL, surf_case, &position);
975 
976   //Position du texte
977   position.x=10;
978   position.y=345;
979   //On colle le texte sur la surface
980   SDL_BlitSurface(surf_texte[18], NULL, surf_case, &position);
981   
982   //Position du texte
983   position.x=(DETAIL_LARGEUR-10-(*surf_texte[19]).w);
984   position.y=365;
985   //On colle le texte sur la surface
986   SDL_BlitSurface(surf_texte[19], NULL, surf_case, &position);
987   
988   //Position du texte
989   position.x=(DETAIL_LARGEUR-(*surf_texte[20]).w)/2;
990   position.y=390;
991   //On colle le texte sur la surface
992   SDL_BlitSurface(surf_texte[20], NULL, surf_case, &position);
993   
994   //Position du texte
995   position.x=(DETAIL_LARGEUR-(*surf_texte[21]).w)/2;
996   position.y=410;
997   //On colle le texte sur la surface
998   SDL_BlitSurface(surf_texte[21], NULL, surf_case, &position);
999       
1000   //Libération des surfaces temporaires
1001   SDL_FreeSurface(surf_fond);
1002   SDL_FreeSurface(surf_groupe_fond);
1003   SDL_FreeSurface(surf_groupe);
1004   for(i=0;i<22;i++) SDL_FreeSurface(surf_texte[i]);
1005   
1006   return(surf_case);
1007 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_detail_lc@{creation\_\-case\_\-detail\_\-lc}}
\index{creation_case_detail_lc@{creation\_\-case\_\-detail\_\-lc}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-detail\_\-lc (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, int {\em int\_\-type})}\label{sdl_8c_09d8d9c5cf899bc2b162e261891915fa}


cr\~{A}©er la surface de la case d\~{A}©taille d'une case lieu commun 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type de lieu commun\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case d\~{A}©taill\~{A}© \end{Desc}


D\'{e}finition \`{a} la ligne 1009 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-lieu\_\-commun().

\begin{Code}\begin{verbatim}1010 {
1011   SDL_Surface* surf_case;
1012   surf_case=NULL;
1013   SDL_Surface* surf_fond;
1014   surf_fond=NULL;
1015   SDL_Surface* surf_image;
1016   surf_image=NULL;
1017   SDL_Surface* surf_sep;
1018   surf_sep=NULL;
1019   SDL_Surface* surf_texte[14];
1020   char texte_temp[256];
1021   int i;
1022   
1023   //Police d'écriture
1024   TTF_Font* police;
1025   police=NULL;
1026 
1027   //Couleur du texte
1028   SDL_Color couleur_texte = {0, 0, 0};
1029   //Couleur du fond du texte
1030   SDL_Color couleur_fond_texte = {225, 255, 225};
1031 
1032   //Position
1033   SDL_Rect position;
1034   
1035   switch(int_type)
1036   {
1037     case LC_WC:
1038       surf_image = IMG_Load("sdl/images/wc.png");
1039       strcpy(texte_temp,"W.C.");
1040       break;
1041     case LC_ASCENSEUR:
1042       surf_image = IMG_Load("sdl/images/ascenseur.png");
1043       strcpy(texte_temp,"Ascenseur");
1044       break;
1045     case LC_RU:
1046       surf_image = IMG_Load("sdl/images/ru.png");
1047       strcpy(texte_temp,"R.U.");
1048       break;
1049     case LC_PARKING:
1050       surf_image = IMG_Load("sdl/images/parking.png");
1051       strcpy(texte_temp,"Parking");
1052       break;
1053     default:
1054       break;
1055   }
1056 
1057   //Ouverture de la police d'ecriture
1058   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 28);
1059 
1060   //Tire de la carte de propriété
1061   surf_texte[1] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
1062 
1063   //Fermeture de la police d'ecriture
1064   TTF_CloseFont(police);
1065     
1066   //Ouverture de la police d'ecriture
1067   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 20);
1068   
1069   //Ecriture des informations contenus dans le groupe
1070   surf_texte[0] = TTF_RenderText_Shaded(police, "Titre de propriété", couleur_texte, couleur_fond_texte);
1071   
1072   //Ecriture des textes sur les informations sur les loyers
1073   surf_texte[2] = TTF_RenderText_Shaded(police, "LOYER si vous avez :", couleur_texte, couleur_fond_texte);
1074   surf_texte[3] = TTF_RenderText_Shaded(police, "1 lieu commun", couleur_texte, couleur_fond_texte);
1075   surf_texte[4] = TTF_RenderText_Shaded(police, "2 lieux commun", couleur_texte, couleur_fond_texte);
1076   surf_texte[5] = TTF_RenderText_Shaded(police, "3 lieux commun", couleur_texte, couleur_fond_texte);
1077   surf_texte[6] = TTF_RenderText_Shaded(police, "4 lieux commun", couleur_texte, couleur_fond_texte);
1078   
1079   //Ecriture de la monnaie utilisé
1080   surf_texte[7] = TTF_RenderText_Shaded(police, "Fintz", couleur_texte, couleur_fond_texte);
1081   
1082   //Ecriture des différents prix
1083   for(i=0;i<4;i++)
1084   {
1085     sprintf(texte_temp,"%d",250*(i+1));
1086     surf_texte[8+i] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
1087   }
1088   
1089   //Fermeture de la police d'ecriture
1090   TTF_CloseFont(police);
1091   
1092   //Ouverture de la police d'ecriture
1093   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
1094   
1095   //Ecriture des informations sur l'achat d'un niveau et l'hypothèque
1096   surf_texte[12] = TTF_RenderText_Shaded(police, "Valeur Hypothécaire de la salle", couleur_texte, couleur_fond_texte);
1097   sprintf(texte_temp,"%d Fintz",1000);
1098   surf_texte[13] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
1099   
1100   //Fermeture de la police d'ecriture
1101   TTF_CloseFont(police);
1102 
1103   //Création de la surface de la case
1104   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR, DETAIL_HAUTEUR, 32, 0, 0, 0, 0);
1105   //Remplissage de noir pour faire le cadre
1106   SDL_FillRect(surf_case, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1107 
1108   //Création de la surface de fond
1109   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR-2*DETAIL_EPAISSEUR, DETAIL_HAUTEUR-2*DETAIL_EPAISSEUR, 32, 0, 0, 0, 0);
1110   //Remplissage de vert tapis
1111   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 225, 255, 225));
1112 
1113   //Création de la surface de séparation
1114   surf_sep=SDL_CreateRGBSurface(SDL_HWSURFACE, (DETAIL_LARGEUR*9)/10, 3, 32, 0, 0, 0, 0);
1115   //Remplissage de noir
1116   SDL_FillRect(surf_sep, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1117 
1118 
1119   //On modifie la position du fond
1120   position.x=DETAIL_EPAISSEUR;
1121   position.y=DETAIL_EPAISSEUR;
1122   //On colle le fond sur la case
1123   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
1124 
1125   //Pour le titre
1126   for(i=0;i<2;i++)
1127   {
1128     //On centre la position du texte
1129     position.x=(DETAIL_LARGEUR-(*surf_texte[i]).w)/2;
1130     position.y=10+25*i;
1131     //On colle le texte sur la surface
1132     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
1133   }
1134 
1135   //On centre la position de l'image
1136   position.x=(DETAIL_LARGEUR-(surf_image->w))/2;
1137   position.y=85;
1138   //On colle l'image sur la surface
1139   SDL_BlitSurface(surf_image, NULL, surf_case, &position);
1140     
1141   for(i=2;i<7;i++)
1142   {
1143     //Modification de la position du texte pour le loyer du terrain nu
1144     position.x=20;
1145     position.y=145+25*i;
1146     //Affichage du loyer du terrain nu
1147     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
1148   }
1149 
1150   //Pour les informations sur les prix
1151   for(i=7;i<12;i++)
1152   {
1153     //On centre la position du texte
1154     position.x=DETAIL_LARGEUR-15-(surf_texte[i]->w);
1155     position.y=145+25*(i-5);
1156     //On colle le texte sur la surface
1157     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
1158   }
1159   
1160   //Position du séparateur de texte
1161   position.x=DETAIL_LARGEUR/20;
1162   position.y=360;
1163   //Affichage du séparateur de texte
1164   SDL_BlitSurface(surf_sep, NULL, surf_case, &position);
1165   
1166   //Position du texte
1167   position.x=(DETAIL_LARGEUR-(*surf_texte[12]).w)/2;
1168   position.y=390;
1169   //On colle le texte sur la surface
1170   SDL_BlitSurface(surf_texte[12], NULL, surf_case, &position);
1171   
1172   //Position du texte
1173   position.x=(DETAIL_LARGEUR-(*surf_texte[13]).w)/2;
1174   position.y=410;
1175   //On colle le texte sur la surface
1176   SDL_BlitSurface(surf_texte[13], NULL, surf_case, &position);
1177       
1178   //Libération des surfaces temporaires
1179   SDL_FreeSurface(surf_fond);
1180   SDL_FreeSurface(surf_image);
1181   for(i=0;i<14;i++) SDL_FreeSurface(surf_texte[i]);
1182   
1183   return(surf_case);
1184 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_detail_assoc@{creation\_\-case\_\-detail\_\-assoc}}
\index{creation_case_detail_assoc@{creation\_\-case\_\-detail\_\-assoc}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}creation\_\-case\_\-detail\_\-assoc (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, int {\em int\_\-type})}\label{sdl_8c_b1f89888807c7ef6c291d054047aedb0}


cr\~{A}©er la surface de la case d\~{A}©taille d'une case association 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em int\_\-type}]type d'association\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface de la case d\~{A}©taill\~{A}© \end{Desc}


D\'{e}finition \`{a} la ligne 1186 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-association().

\begin{Code}\begin{verbatim}1187 {
1188   SDL_Surface* surf_case;
1189   surf_case=NULL;
1190   SDL_Surface* surf_fond;
1191   surf_fond=NULL;
1192   SDL_Surface* surf_image;
1193   surf_image=NULL;
1194   SDL_Surface* surf_sep;
1195   surf_sep=NULL;
1196   SDL_Surface* surf_texte[10];
1197   char texte_temp[256];
1198   int i;
1199   
1200   //Police d'écriture
1201   TTF_Font* police;
1202   police=NULL;
1203 
1204   //Couleur du texte
1205   SDL_Color couleur_texte = {0, 0, 0};
1206   //Couleur du fond du texte
1207   SDL_Color couleur_fond_texte = {225, 255, 225};
1208 
1209   //Position
1210   SDL_Rect position;
1211   
1212   switch(int_type)
1213   {
1214     case BDE:
1215       surf_image = IMG_Load("sdl/images/bureau_bde.png");
1216       strcpy(texte_temp,"B.D.E.");
1217       break;
1218     case BDS:
1219       surf_image = IMG_Load("sdl/images/bureau_bds.png");
1220       strcpy(texte_temp,"B.D.S.");
1221       break;
1222     default:
1223       break;
1224   }
1225 
1226   //Ouverture de la police d'ecriture
1227   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 28);
1228 
1229   //Tire de la carte de propriété
1230   surf_texte[1] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
1231 
1232   //Fermeture de la police d'ecriture
1233   TTF_CloseFont(police);
1234     
1235   //Ouverture de la police d'ecriture
1236   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 20);
1237   
1238   //Ecriture des informations contenus dans le groupe
1239   surf_texte[0] = TTF_RenderText_Shaded(police, "Titre de propriété", couleur_texte, couleur_fond_texte);
1240       
1241   //Fermeture de la police d'ecriture
1242   TTF_CloseFont(police);
1243   
1244   //Ouverture de la police d'ecriture
1245   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
1246   
1247   //Ecriture des textes sur les informations sur les loyers
1248   surf_texte[2] = TTF_RenderText_Shaded(police, "Si l'élève possède UN seul bureau", couleur_texte, couleur_fond_texte);
1249   surf_texte[3] = TTF_RenderText_Shaded(police, "d'association, le droit de passage est", couleur_texte, couleur_fond_texte);
1250   surf_texte[4] = TTF_RenderText_Shaded(police, "40 fois le montant indiqué par les dés", couleur_texte, couleur_fond_texte);
1251   
1252   //Ecriture des textes sur les informations sur les loyers
1253   surf_texte[5] = TTF_RenderText_Shaded(police, "Si l'élève possède les DEUX bureaux", couleur_texte, couleur_fond_texte);
1254   surf_texte[6] = TTF_RenderText_Shaded(police, "d'association, le droit de passage est", couleur_texte, couleur_fond_texte);
1255   surf_texte[7] = TTF_RenderText_Shaded(police, "100 fois le montant indiqué par les dés", couleur_texte, couleur_fond_texte);
1256   
1257   //Ecriture des informations sur l'achat d'un niveau et l'hypothèque
1258   surf_texte[8] = TTF_RenderText_Shaded(police, "Valeur Hypothécaire de la salle", couleur_texte, couleur_fond_texte);
1259   sprintf(texte_temp,"%d Fintz",750);
1260   surf_texte[9] = TTF_RenderText_Shaded(police, texte_temp, couleur_texte, couleur_fond_texte);
1261   
1262   //Fermeture de la police d'ecriture
1263   TTF_CloseFont(police);
1264 
1265   //Création de la surface de la case
1266   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR, DETAIL_HAUTEUR, 32, 0, 0, 0, 0);
1267   //Remplissage de noir pour faire le cadre
1268   SDL_FillRect(surf_case, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1269 
1270   //Création de la surface de fond
1271   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, DETAIL_LARGEUR-2*DETAIL_EPAISSEUR, DETAIL_HAUTEUR-2*DETAIL_EPAISSEUR, 32, 0, 0, 0, 0);
1272   //Remplissage de vert tapis
1273   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 225, 255, 225));
1274 
1275   //Création de la surface de séparation
1276   surf_sep=SDL_CreateRGBSurface(SDL_HWSURFACE, (DETAIL_LARGEUR*9)/10, 3, 32, 0, 0, 0, 0);
1277   //Remplissage de noir
1278   SDL_FillRect(surf_sep, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1279 
1280 
1281   //On modifie la position du fond
1282   position.x=DETAIL_EPAISSEUR;
1283   position.y=DETAIL_EPAISSEUR;
1284   //On colle le fond sur la case
1285   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
1286 
1287   //Pour le titre
1288   for(i=0;i<2;i++)
1289   {
1290     //On centre la position du texte
1291     position.x=(DETAIL_LARGEUR-(*surf_texte[i]).w)/2;
1292     position.y=10+25*i;
1293     //On colle le texte sur la surface
1294     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
1295   }
1296 
1297   //On centre la position de l'image
1298   position.x=(DETAIL_LARGEUR-(surf_image->w))/2;
1299   position.y=85;
1300   //On colle l'image sur la surface
1301   SDL_BlitSurface(surf_image, NULL, surf_case, &position);
1302     
1303   for(i=2;i<5;i++)
1304   {
1305     //Modification de la position du texte pour le loyer du terrain nu
1306     position.x=(DETAIL_LARGEUR-(*surf_texte[i]).w)/2;
1307     position.y=140+20*i;
1308     //Affichage du loyer du terrain nu
1309     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
1310   }
1311   
1312   //Position du séparateur de texte
1313   position.x=DETAIL_LARGEUR/20;
1314   position.y=260;
1315   //Affichage du séparateur de texte
1316   SDL_BlitSurface(surf_sep, NULL, surf_case, &position);
1317 
1318   //Pour les informations sur les prix
1319   for(i=5;i<8;i++)
1320   {
1321     //On centre la position du texte
1322     position.x=(DETAIL_LARGEUR-(*surf_texte[i]).w)/2;
1323     position.y=180+20*i;
1324     //On colle le texte sur la surface
1325     SDL_BlitSurface(surf_texte[i], NULL, surf_case, &position);
1326   }
1327   
1328   //Position du séparateur de texte
1329   position.x=DETAIL_LARGEUR/20;
1330   position.y=360;
1331   //Affichage du séparateur de texte
1332   SDL_BlitSurface(surf_sep, NULL, surf_case, &position);
1333   
1334   //Position du texte
1335   position.x=(DETAIL_LARGEUR-(*surf_texte[8]).w)/2;
1336   position.y=390;
1337   //On colle le texte sur la surface
1338   SDL_BlitSurface(surf_texte[8], NULL, surf_case, &position);
1339   
1340   //Position du texte
1341   position.x=(DETAIL_LARGEUR-(*surf_texte[9]).w)/2;
1342   position.y=410;
1343   //On colle le texte sur la surface
1344   SDL_BlitSurface(surf_texte[9], NULL, surf_case, &position);
1345       
1346   //Libération des surfaces temporaires
1347   SDL_FreeSurface(surf_fond);
1348   SDL_FreeSurface(surf_image);
1349   for(i=0;i<10;i++) SDL_FreeSurface(surf_texte[i]);
1350   
1351   return(surf_case);
1352 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_case_propriete@{creation\_\-case\_\-propriete}}
\index{creation_case_propriete@{creation\_\-case\_\-propriete}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-case\_\-propriete (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf rvb\_\-couleur} {\em couleur}, char $\ast$ {\em texte})}\label{sdl_8c_113216b3a9fcb0b8965ecfcf8afe1040}


cr\~{A}©er la surface de la propri\~{A}©t\~{A}© qui s'affichera dans le panneau des propri\~{A}©t\~{A}©s 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em couleur}]couleur du groupe de la case \item[{\em texte}]nom de la case\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface la propri\~{A}©t\~{A}© \end{Desc}


D\'{e}finition \`{a} la ligne 1354 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par init\_\-case\_\-association(), init\_\-case\_\-lieu\_\-commun(), et init\_\-case\_\-salle().

\begin{Code}\begin{verbatim}1355 {
1356   //Surface de la case
1357   SDL_Surface* surf_case;
1358   surf_case=NULL;
1359   //Surface du fond
1360   SDL_Surface* surf_fond;
1361   surf_fond=NULL;
1362   //Surface du texte
1363   SDL_Surface* surf_texte;
1364   surf_texte=NULL;
1365 
1366   
1367   //Police d'écriture
1368   TTF_Font* police;
1369   police=NULL;
1370 
1371   //Couleur du texte
1372   SDL_Color couleur_texte = {0, 0, 0};
1373   //Couleur du groupe
1374   SDL_Color couleur_groupe = {couleur.rouge,couleur.vert,couleur.bleu};
1375 
1376   //Position
1377   SDL_Rect position;
1378   
1379   //Ouverture de la police d'ecriture
1380   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
1381 
1382   //Ecriture du texte
1383   surf_texte = TTF_RenderText_Shaded(police, texte, couleur_texte, couleur_groupe);
1384   
1385   //Fermeture de la police d'ecriture
1386   TTF_CloseFont(police);
1387 
1388   //Création de la surface de la case
1389   surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, PROPRIETE_LARGEUR, PROPRIETE_HAUTEUR, 32, 0, 0, 0, 0);
1390   //Remplissage de noir pour faire le cadre
1391   SDL_FillRect(surf_case, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1392 
1393   //Création de la surface de fond
1394   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PROPRIETE_LARGEUR-6, PROPRIETE_HAUTEUR-6, 32, 0, 0, 0, 0);
1395   //Remplissage de la couleur du groupe
1396   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, couleur.rouge,couleur.vert,couleur.bleu));
1397 
1398 
1399   //On modifie la position du fond
1400   position.x=3;
1401   position.y=3;
1402   //On colle le fond sur la case
1403   SDL_BlitSurface(surf_fond, NULL, surf_case, &position);
1404 
1405   //Position du texte
1406   position.x=(PROPRIETE_LARGEUR-(surf_texte->w))/2;
1407   position.y=5;
1408   //Collage du texte sur la case
1409   SDL_BlitSurface(surf_texte, NULL, surf_case, &position);
1410       
1411   //Libération des surfaces temporaires
1412   SDL_FreeSurface(surf_fond);
1413   SDL_FreeSurface(surf_texte);
1414   //On retourne la case
1415   return(surf_case);
1416 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_accueil@{affich\_\-accueil}}
\index{affich_accueil@{affich\_\-accueil}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int affich\_\-accueil (SDL\_\-Surface $\ast$ {\em surf\_\-ecran})}\label{sdl_8c_1fc2e44cfc2e20d10fa876ceb767fa29}


affiche la page d'accueil 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]une action demand\~{A}©e du joueur \end{Desc}


D\'{e}finition \`{a} la ligne 1418 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par main().

\begin{Code}\begin{verbatim}1419 {
1420   int i;
1421   char char_nombre[16];
1422   int nombre_joueur;
1423   //Surface du numéro
1424   SDL_Surface* surf_nombre[6];
1425   //Surface de la fleche gauche
1426   SDL_Surface* surf_fleche_gauche;
1427   surf_fleche_gauche=NULL;
1428   //Surface de la fleche droite
1429   SDL_Surface* surf_fleche_droite;
1430   surf_fleche_droite=NULL;
1431   //Surface du titre
1432   SDL_Surface* surf_titre;
1433   surf_titre=NULL;
1434   //Surface du texte
1435   SDL_Surface* surf_texte;
1436   surf_texte=NULL;
1437   //Surface des boutons
1438   SDL_Surface* surf_boutons[6];
1439   //Police d'écriture
1440   TTF_Font* police;
1441   police=NULL;
1442   //Position des images
1443   SDL_Rect position;
1444 
1445   //Couleur du titre
1446   SDL_Color couleur_titre = {231, 86, 86};
1447   //Couleur du texte
1448   SDL_Color couleur_texte = {0, 155, 126};
1449   //Couleur des nombres
1450   SDL_Color couleur_nombre = {255, 0, 0};
1451   
1452   //Remplissage de noir pour faire le fond
1453   SDL_FillRect(surf_ecran, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1454   
1455   //Chargement de l'image de la fleche gauche
1456   surf_fleche_gauche=IMG_Load("sdl/images/fleche_gauche.gif");
1457   //Chargement de l'image de la fleche droite
1458   surf_fleche_droite=IMG_Load("sdl/images/fleche_droite.gif");
1459   
1460   //Création de la surface du bouton valider
1461   surf_boutons[0]=IMG_Load("sdl/images/suivant.gif");
1462   surf_boutons[1]=IMG_Load("sdl/images/suivant2.gif");
1463   surf_boutons[2]=IMG_Load("sdl/images/quitter.gif");
1464   surf_boutons[3]=IMG_Load("sdl/images/quitter2.gif");
1465   surf_boutons[4]=IMG_Load("sdl/images/charger.gif");
1466   surf_boutons[5]=IMG_Load("sdl/images/charger2.gif");
1467   
1468   //Ouverture de la police d'ecriture
1469   police = TTF_OpenFont("sdl/police/police.ttf", 100);
1470   
1471   //Ecriture du titre sur la surface de titre
1472   surf_titre = TTF_RenderText_Blended(police, "EISTIOPOLY", couleur_titre);
1473 
1474   //Pour chacune des surfaces nombre
1475   for(i=0;i<6;i++)
1476   {
1477     //Enregistrement du numéro
1478     sprintf(char_nombre,"%d",i+1);
1479     //Ecriture du numéro sur la surface
1480     surf_nombre[i] = TTF_RenderText_Blended(police, char_nombre, couleur_nombre);
1481   }
1482 
1483   //Fermeture de la police d'ecriture
1484   TTF_CloseFont(police);
1485   
1486   //Ouverture de la police d'ecriture
1487   police = TTF_OpenFont("sdl/police/police.ttf", 60);
1488   
1489   //Ecriture du texte sur la surface de texte
1490   surf_texte = TTF_RenderText_Blended(police, "Nombre de joueur", couleur_texte);
1491   
1492   //Fermeture de la police d'ecriture
1493   TTF_CloseFont(police);
1494   
1495   //On modifie la position du titre
1496   position.x=(ECRAN_LARGEUR-(surf_titre->w))/2;
1497   position.y=TITRE_POS_Y;
1498   //On colle le titre sur le fond
1499   SDL_BlitSurface(surf_titre, NULL, surf_ecran, &position);
1500   
1501   //Position du texte
1502   position.x=(ECRAN_LARGEUR-(surf_texte->w))/2;
1503   position.y=TEXTE_POS_Y;
1504   //Affichage du texte
1505   SDL_BlitSurface(surf_texte, NULL, surf_ecran, &position);
1506   
1507   //On modifie la position du bouton valider
1508   position.x=(ECRAN_LARGEUR-BTN_ACCUEIL_LARGEUR)/2;
1509   position.y=BTN_ACCUEIL_POS_Y;
1510   //On colle le bouton valider sur le fond
1511   SDL_BlitSurface(surf_boutons[0], NULL, surf_ecran, &position);
1512   
1513   //On modifie la position du bouton chargement
1514   position.x=(ECRAN_LARGEUR-BTN_ACCUEIL_LARGEUR)/2;
1515   position.y=BTN_ACCUEIL_POS_Y+BTN_ACCUEIL_ESPACE;
1516   //On colle le bouton charger sur le fond
1517   SDL_BlitSurface(surf_boutons[4], NULL, surf_ecran, &position);
1518   
1519   //On modifie la position du bouton quitter
1520   position.x=ECRAN_LARGEUR-(surf_boutons[2]->w+10);
1521   position.y=10;
1522   //On colle le bouton quitter sur le fond
1523   SDL_BlitSurface(surf_boutons[2], NULL, surf_ecran, &position);
1524 
1525   //Fonction d'attente d'événement
1526   nombre_joueur=attente_action_accueil(surf_ecran, surf_boutons, surf_nombre, surf_fleche_gauche, surf_fleche_droite);
1527   
1528   //On efface l'écran
1529   SDL_FillRect(surf_ecran, NULL, SDL_MapRGB(surf_ecran->format, 25, 25, 75));
1530   //Mise à jour de l'écran
1531   SDL_Flip(surf_ecran);
1532   
1533   //Libération des surfaces utilisées
1534   for(i=0;i<6;i++) SDL_FreeSurface(surf_nombre[i]);
1535   for(i=0;i<6;i++) SDL_FreeSurface(surf_boutons[i]);
1536   SDL_FreeSurface(surf_fleche_gauche);
1537   SDL_FreeSurface(surf_fleche_droite);
1538   SDL_FreeSurface(surf_titre);
1539 
1540   return(nombre_joueur);
1541 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_config@{affich\_\-config}}
\index{affich_config@{affich\_\-config}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int affich\_\-config (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, char $\ast$$\ast$ {\em str\_\-nom\_\-joueur}, int {\em nombre\_\-joueur})}\label{sdl_8c_c9bb689ccc7a4d3545a2b822b5f772a1}


affiche la page de configuration de la partie 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em str\_\-nom\_\-joueur}]tableau des noms des joueurs \item[{\em nombre\_\-joueur}]nombre de joueur dans la partie\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]une action demand\~{A}©e du joueur \end{Desc}


D\'{e}finition \`{a} la ligne 1543 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par main().

\begin{Code}\begin{verbatim}1544 {
1545   int i;
1546   char str_nom[64];
1547   int int_retour;
1548 
1549   //Surface d'un champ (sert de cache)
1550   SDL_Surface* surf_champ;
1551   surf_champ=NULL;
1552   //Surfaces des noms
1553   SDL_Surface* surf_nom[nombre_joueur];
1554 
1555   //Surface du titre
1556   SDL_Surface* surf_titre;
1557   surf_titre=NULL;
1558   //Surface des boutons
1559   SDL_Surface* surf_boutons[6];
1560   //Police d'écriture
1561   TTF_Font* police;
1562   police=NULL;
1563   //Position des images
1564   SDL_Rect position;
1565 
1566   //Couleur du texte
1567   SDL_Color couleur_titre = {231, 86, 86};
1568   //Couleur des noms
1569   SDL_Color couleur_noms = {255, 0, 0};
1570   
1571   //Remplissage de noir pour faire le fond
1572   SDL_FillRect(surf_ecran, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1573 
1574   //Création des surfaces du bouton retour
1575   surf_boutons[0]=IMG_Load("sdl/images/retour.gif");
1576   surf_boutons[1]=IMG_Load("sdl/images/retour2.gif");
1577   surf_boutons[2]=IMG_Load("sdl/images/jouer.gif");
1578   surf_boutons[3]=IMG_Load("sdl/images/jouer2.gif");
1579   surf_boutons[4]=IMG_Load("sdl/images/quitter.gif");
1580   surf_boutons[5]=IMG_Load("sdl/images/quitter2.gif");
1581 
1582   //Ouverture de la police d'ecriture
1583   police = TTF_OpenFont("sdl/police/police.ttf", 100);
1584   
1585   //Ecriture du titre sur la surface de titre
1586   surf_titre = TTF_RenderText_Blended(police, "EISTIOPOLY", couleur_titre);
1587   
1588   //Fermeture de la police d'ecriture
1589   TTF_CloseFont(police);
1590   
1591   //Ouverture de la police d'ecriture
1592   police = TTF_OpenFont("sdl/police/police.ttf", 30);
1593   
1594   //Ecriture du numéro sur la surface
1595   surf_champ=SDL_CreateRGBSurface(SDL_HWSURFACE, CHAMP_LARGEUR, CHAMP_HAUTEUR, 32, 0, 0, 0, 0);
1596   //Remplissage du bouton valider
1597   SDL_FillRect(surf_champ, NULL, SDL_MapRGB(surf_ecran->format, 204, 204, 204));
1598     
1599   //Pour chacune des surfaces nombre
1600   for(i=0;i<nombre_joueur;i++)
1601   {
1602     //Enregistrement du numéro
1603     sprintf(str_nom,"Joueur %d :",i+1);
1604     surf_nom[i] = TTF_RenderText_Blended(police, str_nom, couleur_noms);
1605   }
1606 
1607   //Fermeture de la police d'ecriture
1608   TTF_CloseFont(police);
1609   
1610   //On modifie la position du titre
1611   position.x=TITRE_POS_X;
1612   position.y=TITRE_POS_Y;
1613   //On colle le titre sur le fond
1614   SDL_BlitSurface(surf_titre, NULL, surf_ecran, &position);
1615   
1616   //On modifie la position du bouton valider
1617   position.x=BTN_ACCUEIL_POS_X+20+(surf_boutons[0])->w;
1618   position.y=BTN_ACCUEIL_POS_Y;
1619   //On colle le bouton valider sur le fond
1620   SDL_BlitSurface(surf_boutons[2], NULL, surf_ecran, &position);
1621 
1622   //On modifie la position du bouton retour
1623   position.x=BTN_ACCUEIL_POS_X;
1624   position.y=BTN_ACCUEIL_POS_Y;
1625   //On colle le bouton retour sur le fond
1626   SDL_BlitSurface(surf_boutons[0], NULL, surf_ecran, &position);
1627 
1628   //On modifie la position du bouton quitter
1629   position.x=ECRAN_LARGEUR-(surf_boutons[4]->w+10);
1630   position.y=10;
1631   //On colle le bouton quitter sur le fond
1632   SDL_BlitSurface(surf_boutons[4], NULL, surf_ecran, &position);
1633 
1634   for(i=0;i<nombre_joueur;i++)
1635   {
1636     position.x=CHAMP_POS_X;
1637     position.y=CHAMP_POS_Y+i*2*CHAMP_HAUTEUR;
1638     SDL_BlitSurface(surf_champ, NULL, surf_ecran, &position);
1639     position.x=NOM_CHAMP_POS_X;
1640     position.y=NOM_CHAMP_POS_Y+i*2*CHAMP_HAUTEUR;
1641     SDL_BlitSurface(surf_nom[i], NULL, surf_ecran, &position);
1642   }
1643   
1644   //Fonction d'attente d'événement
1645   int_retour=attente_action_config(surf_ecran, str_nom_joueur, surf_boutons, surf_champ, nombre_joueur);
1646   
1647   //On efface l'écran
1648   SDL_FillRect(surf_ecran, NULL, SDL_MapRGB(surf_ecran->format, 25, 25, 75));
1649   //Mise à jour de l'écran
1650   SDL_Flip(surf_ecran);
1651   
1652   //Libération des surfaces utilisées
1653   for(i=0;i<nombre_joueur;i++)
1654   {
1655     SDL_FreeSurface(surf_nom[i]);
1656   }
1657   SDL_FreeSurface(surf_titre);
1658   for(i=0;i<6;i++) SDL_FreeSurface(surf_boutons[i]);
1659   return(int_retour);
1660 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_case@{affich\_\-case}}
\index{affich_case@{affich\_\-case}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-case (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf cases} $\ast$ {\em pcase})}\label{sdl_8c_4e3b1c5bc7ed1be6722ca01a2789e758}


affiche une case \~{A}  l'\~{A}©cran 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em pcase}]case \~{A}  afficher\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 1662 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par aller\_\-a\_\-jeton(), aller\_\-en\_\-prison\_\-jeton(), attente\_\-validation\_\-propriete(), avancer\_\-jeton(), jeu(), et reculer\_\-jeton().

\begin{Code}\begin{verbatim}1663 {
1664   //Surface de l'image cpi
1665   SDL_Surface* surf_image_cpi;
1666   surf_image_cpi=NULL;
1667   
1668   //Surface de l'image ingé
1669   SDL_Surface* surf_image_inge;
1670   surf_image_inge=NULL;
1671   
1672   //Surface de la case temporaire
1673   SDL_Surface* surf_case;
1674   surf_case=NULL;
1675 
1676   //Position
1677   SDL_Rect position;
1678   
1679   int int_niveau;
1680   
1681   //Chargement de l'image cpi
1682   surf_image_cpi=IMG_Load("sdl/images/cpi.png");
1683   
1684   //Chargement de l'image ingé
1685   surf_image_inge=IMG_Load("sdl/images/inge.png");
1686   
1687   //Création de la surface temporaire de la case en fonction de la position de la case
1688   if(pcase->int_type>=SP_APPARTEMENT && pcase->int_type<=SP_TABLEAU) surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_HAUTEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
1689   else if(pcase->int_position==POSITION_GAUCHE || pcase->int_position==POSITION_DROITE) surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_HAUTEUR, CASE_LARGEUR, 32, 0, 0, 0, 0);
1690   else surf_case=SDL_CreateRGBSurface(SDL_HWSURFACE, CASE_LARGEUR, CASE_HAUTEUR, 32, 0, 0, 0, 0);
1691   
1692   //Position à 0, 0
1693   position.x=0;
1694   position.y=0;
1695   //Collage de la case sur la surface case temporaire
1696   SDL_BlitSurface((*pcase).surf_image, NULL, surf_case, &position);
1697   
1698   //S'il s'agit d'une case salle qui a un niveau supérieur à zéro
1699   if(pcase->int_type==SALLE && pcase->case_salle.int_niveau!=0)
1700   {
1701   
1702     //On initalisation le niveau à 0
1703     int_niveau=1;
1704     
1705     if(pcase->case_salle.int_niveau<=2)
1706     {
1707       //Selon la position de la case
1708       switch(pcase->int_position)
1709       {
1710         case POSITION_HAUT:
1711           //On tourne l'image de 180 degré
1712           surf_image_cpi=rotation_180(surf_image_cpi);
1713           break;
1714         case POSITION_DROITE:
1715           //On tourne l'image de 90 degré
1716           surf_image_cpi=rotation_90(surf_image_cpi);
1717           break;
1718         case POSITION_GAUCHE:
1719           //On tourne l'image de 270 degré
1720           surf_image_cpi=rotation_270(surf_image_cpi);
1721           break;
1722         default:
1723           //On ne fait rien
1724           break;
1725       }
1726         
1727       //Tant que l'image à afficher fait partit du groupe cpi et tant que l'on a pas atteint le niveau de la salle
1728       while(int_niveau<=2 && int_niveau<=(pcase->case_salle.int_niveau))
1729       {
1730         switch(pcase->int_position)
1731         {
1732           case POSITION_HAUT:
1733             //On modifie la position du fond
1734             position.x=(CASE_EPAISSEUR+20*(int_niveau-1));
1735             position.y=CASE_HAUTEUR-CASE_EPAISSEUR-20;
1736             break;
1737           case POSITION_DROITE:
1738             //On modifie la position du fond
1739             position.x=CASE_EPAISSEUR;
1740             position.y=CASE_EPAISSEUR+20*(int_niveau-1);
1741             break;
1742           case POSITION_GAUCHE:
1743             //On modifie la position du fond
1744             position.x=CASE_HAUTEUR-CASE_EPAISSEUR-20;
1745             position.y=(CASE_EPAISSEUR+20*(int_niveau-1));
1746             break;
1747           default:
1748             //On modifie la position du fond
1749             position.x=CASE_EPAISSEUR+20*(int_niveau-1);
1750             position.y=CASE_EPAISSEUR;
1751             break;
1752         }
1753         //On colle le fond sur la case
1754         SDL_BlitSurface(surf_image_cpi, NULL, surf_case, &position);
1755         int_niveau++;
1756       }
1757     }
1758     else
1759     {
1760       //Selon la position de la case
1761       switch(pcase->int_position)
1762       {
1763         case POSITION_HAUT:
1764           //On tourne l'image de 180 degré
1765           surf_image_inge=rotation_180(surf_image_inge);
1766           break;
1767         case POSITION_DROITE:
1768           //On tourne l'image de 90 degré
1769           surf_image_inge=rotation_90(surf_image_inge);
1770           break;
1771         case POSITION_GAUCHE:
1772           //On tourne l'image de 270 degré
1773           surf_image_inge=rotation_270(surf_image_inge);
1774           break;
1775         default:
1776           //On ne fait rien
1777           break;
1778       }
1779       
1780       //Tant que l'image à afficher fait partit du groupe cpi et tant que l'on a pas atteint le niveau de la salle
1781       while(int_niveau<=3 && int_niveau<=(pcase->case_salle.int_niveau)-2)
1782       {
1783         switch(pcase->int_position)
1784         {
1785           case POSITION_HAUT:
1786             //On modifie la position du fond
1787             position.x=(CASE_EPAISSEUR+20*(int_niveau-1));
1788             position.y=CASE_HAUTEUR-CASE_EPAISSEUR-20;
1789             break;
1790           case POSITION_DROITE:
1791             //On modifie la position du fond
1792             position.x=CASE_EPAISSEUR;
1793             position.y=CASE_EPAISSEUR+20*(int_niveau-1);
1794             break;
1795           case POSITION_GAUCHE:
1796             //On modifie la position du fond
1797             position.x=CASE_HAUTEUR-CASE_EPAISSEUR-20;
1798             position.y=(CASE_EPAISSEUR+20*(int_niveau-1));
1799             break;
1800           default:
1801             //On modifie la position du fond
1802             position.x=CASE_EPAISSEUR+20*(int_niveau-1);
1803             position.y=CASE_EPAISSEUR;
1804             break;
1805         }
1806         //On colle le fond sur la case
1807         SDL_BlitSurface(surf_image_inge, NULL, surf_case, &position);
1808         int_niveau++;
1809       }
1810     }
1811   }
1812 
1813   //Position de la case sur l'écran
1814   position.x=(*pcase).rect_coordonnees.x;
1815   position.y=(*pcase).rect_coordonnees.y;
1816   
1817   //Affichage de la case
1818   SDL_BlitSurface(surf_case, NULL, surf_ecran, &position);
1819   
1820   //Libération des surfaces temporaire
1821   SDL_FreeSurface(surf_image_inge);
1822   SDL_FreeSurface(surf_image_cpi);
1823   SDL_FreeSurface(surf_case);
1824 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_case_detail@{affich\_\-case\_\-detail}}
\index{affich_case_detail@{affich\_\-case\_\-detail}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-case\_\-detail (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf cases} $\ast$ {\em pcase})}\label{sdl_8c_eb94195fb3ba8eb67c7e7c6101d31d56}


affiche le d\~{A}©tail d'une case 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em pcase}]case dont on doti afficher le d\~{A}©tail\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 1826 du fichier sdl.c.

\begin{Code}\begin{verbatim}1827 {
1828   SDL_Rect position;
1829   position.x=POS_X_PLATEAU+CASE_HAUTEUR+(TAILLE_CENTRE-DETAIL_LARGEUR)/2;
1830   position.y=POS_Y_PLATEAU+CASE_HAUTEUR+(TAILLE_CENTRE-DETAIL_HAUTEUR)/2;
1831   SDL_BlitSurface(pcase->case_salle.surf_detail, NULL, surf_ecran, &position); // Collage de la surface sur l'écran 
1832 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_centre@{affich\_\-centre}}
\index{affich_centre@{affich\_\-centre}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-centre (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, SDL\_\-Surface $\ast$ {\em surf\_\-centre})}\label{sdl_8c_f14fe728c96d62787df648810e3288c7}


affiche le centre du plateau 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em surf\_\-centre}]surface du centre\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 1834 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-validation\_\-message(), attente\_\-validation\_\-propriete(), et jeu().

\begin{Code}\begin{verbatim}1835 {
1836   SDL_Rect position;
1837   position.x=POS_X_PLATEAU+CASE_HAUTEUR;
1838   position.y=POS_Y_PLATEAU+CASE_HAUTEUR;
1839   SDL_BlitSurface(surf_centre, NULL, surf_ecran, &position); // Collage de la surface sur l'écran 
1840 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_panneau_menu@{affich\_\-panneau\_\-menu}}
\index{affich_panneau_menu@{affich\_\-panneau\_\-menu}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-panneau\_\-menu (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, int {\em int\_\-etat\_\-bouton})}\label{sdl_8c_9bf1846eae0f7207f11fa6ba5f55115c}


affiche le panneau du menu 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em int\_\-etat\_\-bouton}]\~{A}©tat des boutons\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 1842 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-clic(), et jeu().

\begin{Code}\begin{verbatim}1843 {
1844   //Surface du panneau
1845   SDL_Surface* surf_menu;
1846   //Surface du fond du panneau
1847   SDL_Surface* surf_fond;
1848   //Surface des boutons images
1849   SDL_Surface* surf_objet[3];
1850   //Position
1851   SDL_Rect position;
1852   int i;
1853 
1854   //Création de la surface du menu
1855   surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_MENU_LARGEUR, PANNEAU_MENU_HAUTEUR, 32, 0, 0, 0, 0);
1856   //Remplissage de noir pour faire le cadre
1857   SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1858 
1859   //Création de la surface du fond du menu
1860   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_MENU_LARGEUR-6, PANNEAU_MENU_HAUTEUR-6, 32, 0, 0, 0, 0);
1861   //Remplissage de noir pour faire le cadre
1862   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
1863 
1864   //Chargement des boutons
1865   if(int_etat_bouton==1) surf_objet[0]=IMG_Load("sdl/images/quitter2.gif");
1866   else surf_objet[0]=IMG_Load("sdl/images/quitter.gif");
1867   if(int_etat_bouton==2) surf_objet[1]=IMG_Load("sdl/images/sauvegarder2.png");
1868   else surf_objet[1]=IMG_Load("sdl/images/sauvegarder.png");
1869   if(int_etat_bouton==3) surf_objet[2]=IMG_Load("sdl/images/tourner.png");
1870   else surf_objet[2]=IMG_Load("sdl/images/tourner.png");
1871 
1872   //Positon du fond
1873   position.x=3;
1874   position.y=3;
1875   //Collage du fond sur l'image
1876   SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
1877 
1878   //Pour chacun des boutons
1879   for(i=0;i<3;i++)
1880   {
1881     //On position le bouton
1882     position.x=(PANNEAU_OBJET_TAILLE+30)*i+30;
1883     position.y=10;
1884     //Affichage du bouton
1885     SDL_BlitSurface(surf_objet[i], NULL, surf_menu, &position);
1886   }
1887 
1888   //Position du panneau sur l'écran
1889   position.x=PANNEAU_MENU_POS_X;
1890   position.y=PANNEAU_MENU_POS_Y;
1891   //Affichage du panneau
1892   SDL_BlitSurface(surf_menu, NULL, surf_ecran, &position);
1893   
1894   //Mise à jour de l'écran
1895   SDL_Flip(surf_ecran);
1896   
1897   //Libération des surfaces temporaires
1898   SDL_FreeSurface(surf_menu);
1899   SDL_FreeSurface(surf_fond);
1900   for(i=0;i<3;i++) SDL_FreeSurface(surf_objet[i]);
1901 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_panneau_joueur@{affich\_\-panneau\_\-joueur}}
\index{affich_panneau_joueur@{affich\_\-panneau\_\-joueur}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-panneau\_\-joueur (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf joueur} $\ast$ {\em j\_\-anneau\_\-joueurs})}\label{sdl_8c_495f90890052e1cad5f7ad447627e6ec}


affiche le panneau d'information sur le joueur 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em j\_\-anneau\_\-joueurs}]joueur en cours\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 1903 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-clic(), et jeu().

\begin{Code}\begin{verbatim}1904 {
1905   SDL_Surface* surf_menu;
1906   SDL_Surface* surf_fond;
1907   SDL_Surface* surf_texte[5];
1908   
1909   SDL_Rect position_jeton;
1910   
1911   char str_temp[256];
1912   int i;
1913 
1914   SDL_Rect position;
1915 
1916   //Police d'écriture
1917   TTF_Font* police;
1918   police=NULL;
1919 
1920   //Couleur du texte
1921   SDL_Color couleur_texte = {86, 255, 86};
1922   SDL_Color couleur_valeur = {125, 225, 125};
1923 
1924   //Création de la surface du menu
1925   surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_JOUEUR_LARGEUR, PANNEAU_JOUEUR_HAUTEUR, 32, 0, 0, 0, 0);
1926   //Remplissage de noir pour faire le cadre
1927   SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
1928 
1929   //Création de la surface du fond du menu
1930   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_JOUEUR_LARGEUR-6, PANNEAU_JOUEUR_HAUTEUR-6, 32, 0, 0, 0, 0);
1931   //Remplissage de noir pour faire le cadre
1932   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
1933 
1934   //Ouverture de la police d'ecriture
1935   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
1936 
1937   //Ecriture du texte "nom du joueur"
1938   surf_texte[0] = TTF_RenderText_Blended(police, "Nom du joueur :", couleur_texte);
1939 
1940   //Ecriture du nom du joueur
1941   surf_texte[1] = TTF_RenderText_Blended(police, j_anneau_joueurs->str_nom, couleur_valeur);
1942 
1943   sprintf(str_temp,"%d Fintz",j_anneau_joueurs->int_argent);
1944   //Ecriture du texte "argent"
1945   surf_texte[2] = TTF_RenderText_Blended(police, "Argent :", couleur_texte);
1946 
1947   //Ecriture de la quantité d'argent du joueur
1948   surf_texte[3] = TTF_RenderText_Blended(police, str_temp, couleur_valeur);
1949 
1950   sprintf(str_temp,"Nombre de certificat : %d",j_anneau_joueurs->int_certificat);
1951   //Ecriture du nombre de certficat
1952   surf_texte[4] = TTF_RenderText_Blended(police, str_temp, couleur_texte);
1953 
1954   //Fermeture de la police d'ecriture
1955   TTF_CloseFont(police);
1956 
1957   //on affiche l'image du jeton
1958   position_jeton.x=130;
1959   position_jeton.y=25;
1960   SDL_BlitSurface(j_anneau_joueurs->surf_image, NULL, surf_fond, &position_jeton);
1961 
1962   position.x=3;
1963   position.y=3;
1964   SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
1965 
1966   for(i=0;i<5;i++)
1967   {
1968     position.x=PANNEAU_JOUEUR_POS_X+5+(15*(i%2));
1969     position.y=PANNEAU_JOUEUR_POS_Y-95+25*i-5*(i%2);
1970     SDL_BlitSurface(surf_texte[i], NULL, surf_menu, &position);
1971   }
1972 
1973   position.x=PANNEAU_JOUEUR_POS_X;
1974   position.y=PANNEAU_JOUEUR_POS_Y;
1975   SDL_BlitSurface(surf_menu, NULL, surf_ecran, &position);
1976   
1977   SDL_Flip(surf_ecran);
1978   SDL_FreeSurface(surf_menu);
1979   SDL_FreeSurface(surf_fond);
1980   for(i=0;i<3;i++) SDL_FreeSurface(surf_texte[i]);
1981 }
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_panneau_possessions@{affich\_\-panneau\_\-possessions}}
\index{affich_panneau_possessions@{affich\_\-panneau\_\-possessions}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-panneau\_\-possessions (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf joueur} $\ast$ {\em j\_\-anneau\_\-joueurs})}\label{sdl_8c_83fed3d7a65d02378d31795cab19b73d}


affiche le panneau des possessions du joueur 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em j\_\-anneau\_\-joueurs}]joueur en cours\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 1983 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-clic(), et jeu().

\begin{Code}\begin{verbatim}1984 {
1985   //Surface du panneau
1986   SDL_Surface* surf_menu;
1987   surf_menu=NULL;
1988   SDL_Surface* surf_fond;
1989   surf_fond=NULL;
1990   SDL_Surface* surf_texte;
1991   surf_texte=NULL;
1992   SDL_Rect position;
1993   SDL_Surface* surf_propriete;
1994   surf_propriete=NULL;
1995   //Police d'écriture
1996   TTF_Font* police;
1997   police=NULL;
1998   possession* propriete;
1999   int nombre_propriete;
2000   int propriete_actuel;
2001   SDL_Color couleur_texte = {86, 255, 86};
2002   propriete=j_anneau_joueurs->propriete;
2003   propriete_actuel=0;
2004   nombre_propriete=0;
2005   
2006   if(!propriete)
2007   {
2008     //Création de la surface du menu
2009     surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_POSSESSION_LARGEUR, PANNEAU_POSSESSION_HAUTEUR, 32, 0, 0, 0, 0);
2010     //Remplissage de noir pour faire le cadre
2011     SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
2012 
2013     //Création de la surface du fond du menu
2014     surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_POSSESSION_LARGEUR-6, PANNEAU_POSSESSION_HAUTEUR-6, 32, 0, 0, 0, 0);
2015     //Remplissage de noir pour faire le cadre
2016     SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
2017 
2018     //Ouverture de la police d'ecriture
2019     police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
2020 
2021     //Ecriture du texte "nom du joueur"
2022     surf_texte = TTF_RenderText_Blended(police, "Aucun titre de propriété.", couleur_texte);
2023 
2024     //Fermeture de la police d'ecriture
2025     TTF_CloseFont(police);
2026     
2027     position.x=3;
2028     position.y=3;
2029     SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
2030   
2031   }
2032   else
2033   {
2034     //Pour chaque propriete
2035     while(propriete)
2036     {
2037       //On ajoute 1 au nombre de propriété
2038       nombre_propriete++;
2039       //On passe à la propriété suivante
2040       propriete=propriete->suivant;
2041     }
2042     //Création de la surface du panneau
2043     surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_POSSESSION_LARGEUR, 40+((PROPRIETE_HAUTEUR+5)*nombre_propriete), 32, 0, 0, 0, 0);
2044     //Remplissage de noir pour faire le cadre
2045     SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
2046 
2047     //Création de la surface du fond du panneau
2048     surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_POSSESSION_LARGEUR-6, 40+((PROPRIETE_HAUTEUR+5)*nombre_propriete)-6, 32, 0, 0, 0, 0);
2049     //Remplissage de noir pour faire le cadre
2050     SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
2051 
2052     //Ouverture de la police d'ecriture
2053     police = TTF_OpenFont("sdl/police/police2-bold.ttf", 17);
2054 
2055     //Ecriture du texte
2056     surf_texte = TTF_RenderText_Blended(police, "Propriété de l'élève :", couleur_texte);
2057 
2058     //Fermeture de la police d'ecriture
2059     TTF_CloseFont(police);
2060     
2061     //Position du fond sur le menu
2062     position.x=3;
2063     position.y=3;
2064     //Collage du fond sur le menu
2065     SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
2066   
2067     //Retour à l'entete de la liste des propriétés du joueur
2068     propriete=j_anneau_joueurs->propriete;
2069     
2070     //tant qu'on a des propriétés
2071     while(propriete)
2072     {
2073       //Chargement de la surface en fonction de la propriété
2074       if(propriete->propriete->int_type==SALLE) surf_propriete=propriete->propriete->case_salle.surf_propriete;
2075       else if(propriete->propriete->int_type==BDE || propriete->propriete->int_type==BDS) surf_propriete=propriete->propriete->case_association.surf_propriete;
2076       else surf_propriete=propriete->propriete->case_lieu_commun.surf_propriete;
2077 
2078       //Position de la propriété dans le menu
2079       position.x=10;
2080       position.y=35+propriete_actuel*(PROPRIETE_HAUTEUR+5);
2081 
2082       //Affichage de la propriété
2083       SDL_BlitSurface(surf_propriete, NULL, surf_menu, &position);
2084       //Passage à la propriété suivante
2085       propriete=propriete->suivant;
2086       //Incrémentation du nombre de propriété actuel
2087       propriete_actuel++;
2088     }
2089   }
2090 
2091   //Position du texte sur le menu
2092   position.x=20;
2093   position.y=10;
2094   //Collage du texte sur le menu
2095   SDL_BlitSurface(surf_texte, NULL, surf_menu, &position);
2096   
2097   //Position du panneau à l'écran
2098   position.x=PANNEAU_POSSESSION_POS_X;
2099   position.y=PANNEAU_POSSESSION_POS_Y;
2100   //Affichage du panneau à l'écran
2101   SDL_BlitSurface(surf_menu, NULL, surf_ecran, &position);
2102     
2103   //Mise à jour de l'écran
2104   SDL_Flip(surf_ecran);
2105   
2106   //Libération des surfaces temporaires
2107   SDL_FreeSurface(surf_menu);
2108   SDL_FreeSurface(surf_fond);
2109   SDL_FreeSurface(surf_texte);
2110 }
2111 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_possessions_cache@{affich\_\-possessions\_\-cache}}
\index{affich_possessions_cache@{affich\_\-possessions\_\-cache}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-possessions\_\-cache (SDL\_\-Surface $\ast$ {\em surf\_\-ecran})}\label{sdl_8c_c6da71ddb898e1d2fdc238b7cec7d65e}


affiche le cache du panneau de possesion du joueur 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 2113 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par jeu().

\begin{Code}\begin{verbatim}2113 {
2114   //Surface du cache
2115   SDL_Surface* surf_cache;
2116   surf_cache=NULL;
2117   
2118   //Position
2119   SDL_Rect position;
2120   
2121   //Création de la surface du menu
2122   surf_cache=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_POSSESSION_LARGEUR, ECRAN_HAUTEUR-PANNEAU_POSSESSION_POS_Y, 32, 0, 0, 0, 0);
2123   //Remplissage de noir pour faire le cadre
2124   SDL_FillRect(surf_cache, NULL, SDL_MapRGB(surf_ecran->format, 25, 25, 75));
2125   
2126   //Position du cache
2127   position.x=PANNEAU_POSSESSION_POS_X;
2128   position.y=PANNEAU_POSSESSION_POS_Y;
2129   
2130   //Collage du cache sur l'écran
2131   SDL_BlitSurface(surf_cache, NULL, surf_ecran, &position);
2132   
2133 }
2134 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_panneau_des_bouton@{affich\_\-panneau\_\-des\_\-bouton}}
\index{affich_panneau_des_bouton@{affich\_\-panneau\_\-des\_\-bouton}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-panneau\_\-des\_\-bouton (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, int {\em int\_\-image})}\label{sdl_8c_9af391caac0ca5797ffd9cb84b04b860}


affiche le panneau contenant le bouton lancer d\~{A}© 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em int\_\-image}]score du d\~{A}©\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 2136 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-clic(), et jeu().

\begin{Code}\begin{verbatim}2136 {
2137   //Surface du panneau
2138   SDL_Surface* surf_menu;
2139   //Surface du fond
2140   SDL_Surface* surf_fond;
2141   //Surface des boutons lancer dés
2142   SDL_Surface* surf_bouton[2];
2143   //Position
2144   SDL_Rect position;
2145   
2146   int i;
2147 
2148   //Création de la surface du menu
2149   surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_DES_LARGEUR, PANNEAU_DES_HAUTEUR, 32, 0, 0, 0, 0);
2150   //Remplissage de noir pour faire le cadre
2151   SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
2152 
2153   //Création de la surface du fond du menu
2154   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_DES_LARGEUR-6, PANNEAU_DES_HAUTEUR-6, 32, 0, 0, 0, 0);
2155   //Remplissage de noir pour faire le cadre
2156   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
2157 
2158   //Chargement des images bes boutons
2159   surf_bouton[0]=IMG_Load("sdl/images/lancer.gif");
2160   surf_bouton[1]=IMG_Load("sdl/images/lancer2.gif");
2161 
2162   //Position du fond sur le panneau
2163   position.x=3;
2164   position.y=3;
2165   //Collage du fond sur le panneau
2166   SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
2167 
2168   //Position du bouton sur le panneau
2169   position.x=(PANNEAU_DES_LARGEUR-surf_bouton[0]->w)/2;
2170   position.y=(PANNEAU_DES_HAUTEUR-surf_bouton[0]->h)/2;
2171   //Collage du bouton sur le panneau
2172   SDL_BlitSurface(surf_bouton[int_image], NULL, surf_menu, &position);
2173 
2174   //Position du panneau sur l'écran
2175   position.x=PANNEAU_DES_POS_X;
2176   position.y=PANNEAU_DES_POS_Y;
2177   //Affichage du panneau
2178   SDL_BlitSurface(surf_menu, NULL, surf_ecran, &position);
2179   
2180   //Mise à jour de l'écran
2181   SDL_Flip(surf_ecran);
2182   
2183   //Libération des surfaces temporaires
2184   SDL_FreeSurface(surf_menu);
2185   SDL_FreeSurface(surf_fond);
2186   for(i=0;i<2;i++) SDL_FreeSurface(surf_bouton[i]);
2187 }
2188 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_des@{creation\_\-des}}
\index{creation_des@{creation\_\-des}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$$\ast$ creation\_\-des (void)}\label{sdl_8c_bc1cdf56ae3b532e71353fba4dc5f51f}


renvoit un tableau de surface contenant chacune des faces du d\~{A}© 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]le tableau des surfaces des faces du d\~{A}© \end{Desc}


D\'{e}finition \`{a} la ligne 2190 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par lancer\_\-des().

\begin{Code}\begin{verbatim}2190 {
2191   //Surface du dé
2192   SDL_Surface** surf_des;
2193   if((surf_des= new SDL_Surface*[6])==NULL) cout<<"Fesse en boite"<<endl;
2194   //Création de la surface de l'objet n°1
2195   surf_des[0]=IMG_Load("sdl/images/un.png");
2196   surf_des[1]=IMG_Load("sdl/images/deux.png");
2197   surf_des[2]=IMG_Load("sdl/images/trois.png");
2198   surf_des[3]=IMG_Load("sdl/images/quatre.png");
2199   surf_des[4]=IMG_Load("sdl/images/cinq.png");
2200   surf_des[5]=IMG_Load("sdl/images/six.png");
2201   //On retourne la surface du dé
2202   return(surf_des);
2203 }
2204 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!destruction_des@{destruction\_\-des}}
\index{destruction_des@{destruction\_\-des}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void destruction\_\-des (SDL\_\-Surface $\ast$$\ast$ {\em surf\_\-des})}\label{sdl_8c_5f0ca65fa2d890a4e600402ecfeecf2a}


d\~{A}©truit les surfaces des d\~{A}©s 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-des}]tableau des surfaces des faces d'un d\~{A}©\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 2206 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par lancer\_\-des().

\begin{Code}\begin{verbatim}2206 {
2207   int i;
2208   //Libération des surfaces des dés
2209   for(i=0;i<5;i++) SDL_FreeSurface(surf_des[i]);
2210   //Libération de la mémoire
2211   delete(surf_des);
2212 }
2213 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_panneau_fdt@{affich\_\-panneau\_\-fdt}}
\index{affich_panneau_fdt@{affich\_\-panneau\_\-fdt}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-panneau\_\-fdt (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, bool {\em bool\_\-etat})}\label{sdl_8c_073bdb2b8f511320c7066db35a452185}


affiche le panneau du menu 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em bool\_\-etat}]\~{A}©tat des boutons\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 2215 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-clic(), et jeu().

\begin{Code}\begin{verbatim}2215 {
2216   //Surface du panneau
2217   SDL_Surface* surf_menu;
2218   //Surface du fond du panneau
2219   SDL_Surface* surf_fond;
2220   //Surface du bouton de fin de tour
2221   SDL_Surface* surf_bouton;
2222   //Position
2223   SDL_Rect position;
2224 
2225   //Création de la surface du menu
2226   surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_FDT_LARGEUR, PANNEAU_FDT_HAUTEUR, 32, 0, 0, 0, 0);
2227   //Remplissage de noir pour faire le cadre
2228   SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
2229 
2230   //Création de la surface du fond du menu
2231   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_FDT_LARGEUR-6, PANNEAU_FDT_HAUTEUR-6, 32, 0, 0, 0, 0);
2232   //Remplissage de noir pour faire le cadre
2233   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
2234 
2235   //Bouton en surbrillance
2236   if(bool_etat==true) surf_bouton=IMG_Load("sdl/images/finir2.gif");
2237   //Bouton normal
2238   else surf_bouton=IMG_Load("sdl/images/finir.gif");
2239 
2240   //Position du fond sur le panneau
2241   position.x=3;
2242   position.y=3;
2243   //Collage du fond sur le panneau
2244   SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
2245 
2246   //Position du bouton
2247   position.x=(PANNEAU_FDT_LARGEUR-surf_bouton->w)/2;
2248   position.y=(PANNEAU_FDT_HAUTEUR-surf_bouton->h)/2;
2249   //Collage du bouton sur le panneau
2250   SDL_BlitSurface(surf_bouton, NULL, surf_menu, &position);
2251 
2252   //Position du panneau à l'écran
2253   position.x=PANNEAU_FDT_POS_X;
2254   position.y=PANNEAU_FDT_POS_Y;
2255   //Collage du panneau sur l'écran
2256   SDL_BlitSurface(surf_menu, NULL, surf_ecran, &position);
2257   
2258   //Mise à jour de l'écran
2259   SDL_Flip(surf_ecran);
2260   
2261   //Libération des surfaces temporaires
2262   SDL_FreeSurface(surf_menu);
2263   SDL_FreeSurface(surf_fond);
2264   SDL_FreeSurface(surf_bouton);
2265 }
2266 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_panneau_des@{affich\_\-panneau\_\-des}}
\index{affich_panneau_des@{affich\_\-panneau\_\-des}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-panneau\_\-des (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, SDL\_\-Surface $\ast$$\ast$ {\em surf\_\-des}, int {\em int\_\-de1}, int {\em int\_\-de2})}\label{sdl_8c_1ec83ae30cba581d2675dfb5f858efe4}


affiche le panneau du menu 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em surf\_\-des}]tableau des surfaces des face du d\~{A}© \item[{\em int\_\-de1}]score du d\~{A}© num\~{A}©ro 1 \item[{\em int\_\-de2}]score du d\~{A}© num\~{A}©ro 2\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]+++++++++++++++++++++++++++++++++++++++++++++++++ \end{Desc}


D\'{e}finition \`{a} la ligne 2268 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par lancer\_\-des().

\begin{Code}\begin{verbatim}2268 {
2269   //Surface du menu
2270   SDL_Surface* surf_menu;
2271   //Surface du fond
2272   SDL_Surface* surf_fond;
2273 
2274   //Position
2275   SDL_Rect position;
2276 
2277   //Création de la surface du menu
2278   surf_menu=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_DES_LARGEUR, PANNEAU_DES_HAUTEUR, 32, 0, 0, 0, 0);
2279   //Remplissage de noir pour faire le cadre
2280   SDL_FillRect(surf_menu, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
2281 
2282   //Création de la surface du fond du menu
2283   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, PANNEAU_DES_LARGEUR-6, PANNEAU_DES_HAUTEUR-6, 32, 0, 0, 0, 0);
2284   //Remplissage de noir pour faire le cadre
2285   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 125));
2286 
2287   //Position du fond
2288   position.x=3;
2289   position.y=3;
2290   //Affichage du fond
2291   SDL_BlitSurface(surf_fond, NULL, surf_menu, &position);
2292 
2293   //Position du premier dé
2294   position.x=40;
2295   position.y=(PANNEAU_DES_HAUTEUR-surf_des[0]->h)/2;
2296   //Affichage du premier dé
2297   SDL_BlitSurface(surf_des[int_de1-1], NULL, surf_menu, &position);
2298   
2299   //Position du second dé
2300   position.x=130;
2301   position.y=(PANNEAU_DES_HAUTEUR-surf_des[0]->h)/2;
2302   //Affichage du second dé
2303   SDL_BlitSurface(surf_des[int_de2-1], NULL, surf_menu, &position);
2304 
2305   //Position du menu
2306   position.x=PANNEAU_DES_POS_X;
2307   position.y=PANNEAU_DES_POS_Y;
2308   //Affichage du menu
2309   SDL_BlitSurface(surf_menu, NULL, surf_ecran, &position);
2310   
2311   //Mise à jour de l'écran
2312   SDL_Flip(surf_ecran);
2313   
2314   //Libération des surfaces temporaires
2315   SDL_FreeSurface(surf_menu);
2316   SDL_FreeSurface(surf_fond);
2317 }
2318 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_joueur_depart@{affich\_\-joueur\_\-depart}}
\index{affich_joueur_depart@{affich\_\-joueur\_\-depart}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-joueur\_\-depart (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, {\bf cases} $\ast$$\ast$ {\em plateau}, {\bf joueur} $\ast$ {\em j\_\-anneau\_\-joueurs}, int {\em nombre\_\-joueur})}\label{sdl_8c_ede4b283ece193d76b1061a3ebdb19cf}


affiche tout les joueurs sur la case de d\~{A}©part 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em plateau}]plateau de jeu \item[{\em j\_\-anneau\_\-joueurs}]liste cha\~{A}®n\~{A}©e des joueurs \item[{\em nombre\_\-joueur}]nombre de joueur\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]action ud joueur \end{Desc}


D\'{e}finition \`{a} la ligne 2320 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par jeu().

\begin{Code}\begin{verbatim}2320 {
2321   //pour chaque joueurs
2322   for (int i=0;i<nombre_joueur;i++)
2323   {
2324     //on l'affiche sur la case
2325     affich_joueur(surf_ecran,j_anneau_joueurs,i, plateau[j_anneau_joueurs->int_position]);
2326     
2327     //on passe au joueur suivant
2328     j_anneau_joueurs=j_anneau_joueurs->pjoueur_suivant;
2329   }
2330   //on depart au premier joueur pour que le jeu puisse commencer avec
2331   j_anneau_joueurs=j_anneau_joueurs->pjoueur_suivant;
2332 }
2333 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_validation_propriete@{affich\_\-validation\_\-propriete}}
\index{affich_validation_propriete@{affich\_\-validation\_\-propriete}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int affich\_\-validation\_\-propriete (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, SDL\_\-Surface $\ast$ {\em surf\_\-fond}, int {\em int\_\-etat}, int {\em int\_\-nombre\_\-boutons},  {\em ...})}\label{sdl_8c_733742fc69cbf073d8d2d1da7fc0bff2}


affiche le message des propri\~{A}©t\~{A}© ainsi que les boutons d'actions possibles 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em surf\_\-fond}]surface de la propri\~{A}©t\~{A}© \item[{\em int\_\-etat}]\~{A}©tat des boutons \item[{\em int\_\-nombre\_\-boutons}]nombre de boutons \~{A}  afficher \item[{\em ...}]liste des boutons \~{A}  afficher\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]un entier d'\~{A}©tat \end{Desc}


D\'{e}finition \`{a} la ligne 2335 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par action\_\-to\_\-boutons().

\begin{Code}\begin{verbatim}2335 {
2336   //Surface du bouton
2337   SDL_Surface** surf_bouton;
2338   
2339   int i;
2340   
2341   //Nombre de bouton
2342   int nombre_boutons;
2343   nombre_boutons=int_nombre_boutons;
2344   
2345   //Si jamais il n'y a pas de boutons
2346   if(nombre_boutons<=0) return(0);
2347   
2348   //Un crée un tableau de bouton correspondant au nombres de boutons et à leurs états
2349   surf_bouton= new SDL_Surface*[nombre_boutons];
2350 
2351   //Position
2352   SDL_Rect position;
2353   
2354   //Valeur de l'argument
2355   int int_valeur;
2356   
2357   //Liste des arguments
2358   va_list arguments;
2359   
2360   //Initialisation de la liste des arguments
2361   va_start(arguments, int_nombre_boutons);
2362   
2363   //Position du message à l'écran
2364   position.x=DETAIL_MESSAGE_POS_X;
2365   position.y=DETAIL_MESSAGE_POS_Y;
2366   //Affichage du message
2367   SDL_BlitSurface(surf_fond, NULL, surf_ecran, &position); // Collage de la surface sur l'écran
2368   
2369   //Tant qu'on a des boutons
2370   while(nombre_boutons!=0)
2371   {
2372     //Récupération de l'argument
2373     int_valeur=va_arg(arguments, int);
2374     //Selon le bouton à afficher
2375     switch(int_valeur)
2376     {
2377       //Dans le cas d'un achat
2378       case BTN_ACHAT:
2379         //Charger l'image en surbrillance
2380         if(int_etat==int_nombre_boutons-nombre_boutons+1) surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/acheter2.gif");
2381         //Ou l'image normale
2382         else surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/acheter.gif");
2383         break;
2384       //Dans le cas d'un hypothèque
2385       case BTN_HYPOTHEQUE:
2386         //Charger l'image en surbrillance
2387         if(int_etat==int_nombre_boutons-nombre_boutons+1) surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/hypotheque2.gif");
2388         //Ou l'image normale
2389         else surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/hypotheque.gif");
2390         break;
2391       //Dans le cas d'une déshypothèque
2392       case BTN_UNHYPOTHEQUE:
2393         //Charger l'image en surbrillance
2394         if(int_etat==int_nombre_boutons-nombre_boutons+1) surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/deshypotheque2.gif");
2395         //Ou l'image normale
2396         else surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/deshypotheque.gif");
2397         break;
2398       case BTN_MOINS:
2399         //Charger l'image en surbrillance
2400         if(int_etat==int_nombre_boutons-nombre_boutons+1) surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/moins2.gif");
2401         //Ou l'image normale
2402         else surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/moins.gif");
2403         break;
2404       case BTN_PLUS:
2405         //Charger l'image en surbrillance
2406         if(int_etat==int_nombre_boutons-nombre_boutons+1) surf_bouton[0]=IMG_Load("sdl/images/plus2.gif");
2407         //Ou l'image normale
2408         else surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/plus.gif");
2409         break;
2410       case BTN_FINIR:
2411         //Charger l'image en surbrillance
2412         if(int_etat==int_nombre_boutons-nombre_boutons+1) surf_bouton[0]=IMG_Load("sdl/images/annuler2.gif");
2413         //Ou l'image normale
2414         else surf_bouton[nombre_boutons-1]=IMG_Load("sdl/images/annuler.gif");
2415         break;
2416     }
2417     //Passage au bouton suivant
2418     nombre_boutons--;
2419     //Position du bouton
2420     position.x=DETAIL_BOUTON_POS_X;
2421     position.y=DETAIL_BOUTON_POS_Y+50*(int_nombre_boutons-(nombre_boutons+1));
2422     //On colle le bouton sur le message
2423     SDL_BlitSurface(surf_bouton[nombre_boutons], NULL, surf_ecran, &position);
2424   }
2425   
2426   //Destruction de la liste d'argument
2427   va_end(arguments);
2428   
2429   //Mise à jour de l'écran
2430   SDL_Flip(surf_ecran);
2431 
2432   //Libération des surfaces temporaire
2433   for(i=0;i<int_nombre_boutons;i++) SDL_FreeSurface(surf_bouton[i]);
2434   //Libération de la mémoire
2435   delete[] surf_bouton;
2436   
2437   //On retourne 0
2438   return(0);
2439 }
2440 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!creation_message@{creation\_\-message}}
\index{creation_message@{creation\_\-message}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}SDL\_\-Surface $\ast$ creation\_\-message (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, char $\ast$ {\em titre}, char $\ast$$\ast$ {\em message}, int {\em int\_\-type\_\-message}, int {\em int\_\-nbre\_\-ligne})}\label{sdl_8c_0ea4177d482f979a610352eba00b91c6}


cr\~{A}©er la surface d'un message \~{A}  afficher 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em titre}]titre du message \item[{\em message}]message \~{A}  afficher \item[{\em int\_\-type\_\-message}]type du message \~{A}  afficher \item[{\em int\_\-nbre\_\-ligne}]nombre de ligne du message\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]la surface du message \end{Desc}


D\'{e}finition \`{a} la ligne 2442 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-validation\_\-message().

\begin{Code}\begin{verbatim}2442 {
2443   //Surface du message
2444   SDL_Surface* surf_message;
2445   surf_message=NULL;
2446   
2447   //Surface du fond du message
2448   SDL_Surface* surf_fond;
2449   surf_fond=NULL;
2450   
2451   //Surface du texte
2452   SDL_Surface* surf_texte[int_nbre_ligne];
2453   
2454   //Surface du titre
2455   SDL_Surface* surf_titre;
2456   surf_titre=NULL;
2457 
2458   //Police d'écriture
2459   TTF_Font* police;
2460   police=NULL;
2461   
2462   int i;
2463 
2464   //Couleur du texte
2465   SDL_Color couleur_texte = {0, 0, 0};
2466   //Couleur du groupe
2467   SDL_Color couleur_fond_texte = {0,0,0};
2468   
2469   //Selon le type de message, on change la couleur de fond du message
2470   switch(int_type_message)
2471   {
2472     //Dans le cas d'un message de Krystel
2473     case MESSAGE_KRYSTEL:
2474       couleur_fond_texte.r=85;
2475       couleur_fond_texte.g=115;
2476       couleur_fond_texte.b=215;
2477       break;
2478     //Dans le cas d'un message de Nadège
2479     case MESSAGE_NADEGE:
2480       couleur_fond_texte.r=215;
2481       couleur_fond_texte.g=85;
2482       couleur_fond_texte.b=45;
2483       break;
2484     //Dans tout les autres cas
2485     default:
2486       couleur_fond_texte.r=185;
2487       couleur_fond_texte.g=235;
2488       couleur_fond_texte.b=140;
2489       break;
2490   }
2491 
2492   //Position
2493   SDL_Rect position;
2494   
2495   //Si il y à un titre
2496   if(titre)
2497   {
2498     //Ouverture de la police d'ecriture
2499     police = TTF_OpenFont("sdl/police/police2-bold.ttf", 30);
2500 
2501     //Ecriture du titre
2502     surf_titre = TTF_RenderText_Shaded(police, titre, couleur_texte, couleur_fond_texte);
2503     
2504     //Fermeture de la police d'ecriture
2505     TTF_CloseFont(police);
2506   }
2507   
2508   //Ouverture de la police d'ecriture
2509   police = TTF_OpenFont("sdl/police/police2-bold.ttf", 20);
2510 
2511   //Ecriture du texte
2512   for(i=0;i<int_nbre_ligne;i++) surf_texte[i] = TTF_RenderText_Shaded(police, message[i], couleur_texte, couleur_fond_texte);
2513   
2514   //Fermeture de la police d'ecriture
2515   TTF_CloseFont(police);
2516 
2517   //Création de la surface du message
2518   surf_message=SDL_CreateRGBSurface(SDL_HWSURFACE, MESSAGE_LARGEUR, 180+(int_nbre_ligne*20), 32, 0, 0, 0, 0);
2519   //Remplissage de noir pour faire le cadre
2520   SDL_FillRect(surf_message, NULL, SDL_MapRGB(surf_ecran->format, 0, 0, 0));
2521 
2522   //Création de la surface de fond
2523   surf_fond=SDL_CreateRGBSurface(SDL_HWSURFACE, MESSAGE_LARGEUR-6, 180+(int_nbre_ligne*20)-6, 32, 0, 0, 0, 0);
2524   //Remplissage de la couleur du groupe
2525   SDL_FillRect(surf_fond, NULL, SDL_MapRGB(surf_ecran->format, couleur_fond_texte.r, couleur_fond_texte.g, couleur_fond_texte.b));
2526 
2527   //On modifie la position du fond
2528   position.x=3;
2529   position.y=3;
2530   //On colle le fond sur la case
2531   SDL_BlitSurface(surf_fond, NULL, surf_message, &position);
2532 
2533   //Si il y a un titre
2534   if(titre)
2535   {
2536     //Position du titre
2537     position.x=position.x=(MESSAGE_LARGEUR-(surf_titre->w))/2;;
2538     position.y=20;
2539     //Affichage du titre
2540     SDL_BlitSurface(surf_titre, NULL, surf_message, &position);
2541   }
2542 
2543   //Pour chaque ligne du texte
2544   for(i=0;i<int_nbre_ligne;i++)
2545   {
2546     //Position de la ligne de texte
2547     position.x=(MESSAGE_LARGEUR-(surf_texte[i]->w))/2;
2548     position.y=60+20*i;
2549     //Affichage de la ligne du texte
2550     SDL_BlitSurface(surf_texte[i], NULL, surf_message, &position);
2551   }
2552 
2553   //Libération des surfaces temporaires
2554   SDL_FreeSurface(surf_fond);
2555   for(i=0;i<int_nbre_ligne;i++) SDL_FreeSurface(surf_texte[i]);
2556   
2557   //Si il y a un titre, on libère la surface du titre
2558   if(titre) SDL_FreeSurface(surf_titre);
2559   
2560   
2561   //On retourne la surface du message
2562   return(surf_message);
2563   
2564 }
2565 
\end{verbatim}\end{Code}


\index{sdl.c@{sdl.c}!affich_message@{affich\_\-message}}
\index{affich_message@{affich\_\-message}!sdl.c@{sdl.c}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void affich\_\-message (SDL\_\-Surface $\ast$ {\em surf\_\-ecran}, SDL\_\-Surface $\ast$ {\em surf\_\-message}, int {\em int\_\-type\_\-message}, int {\em int\_\-etat})}\label{sdl_8c_4ea2e9aabfae30a56b206b67109e9c03}


affiche un message \~{A}  l'\~{A}©cran 

\begin{Desc}
\item[Auteur:]Franck Trey $<${\tt franck.trey@eisti.fr}$>$, Florian Lefevre $<${\tt florian.lefevre@eisti.fr}$>$\end{Desc}
\begin{Desc}
\item[Param\`{e}tres:]
\begin{description}
\item[{\em surf\_\-ecran}]surface de l'\~{A}©cran \item[{\em surf\_\-message}]surface du message \item[{\em int\_\-type\_\-message}]type du message \~{A}  afficher \item[{\em int\_\-etat}]\~{A}©tat des boutons\end{description}
\end{Desc}
\begin{Desc}
\item[Version:]1.0 \end{Desc}
\begin{Desc}
\item[Renvoie:]rien \end{Desc}


D\'{e}finition \`{a} la ligne 2568 du fichier sdl.c.

R\'{e}f\'{e}renc\'{e} par attente\_\-validation\_\-message().

\begin{Code}\begin{verbatim}2568 {
2569   //Surface du bouton
2570   SDL_Surface* surf_bouton[3];
2571   
2572   int i;
2573   
2574   //Position
2575   SDL_Rect position;
2576   
2577   //Initialisation des trois boutons
2578   for(i=0;i<3;i++) surf_bouton[i]=NULL;
2579   
2580   //S'il s'agit d'un message quitter
2581   if(int_type_message==MESSAGE_QUITTER)
2582   {
2583     //Chargement de l'image en surbrillance
2584     if(int_etat==1) surf_bouton[0]=IMG_Load("sdl/images/exit2.gif");
2585     //En normal
2586     else surf_bouton[0]=IMG_Load("sdl/images/exit.gif");
2587     //Chargement de l'image en surbrillance
2588     if(int_etat==2) surf_bouton[1]=IMG_Load("sdl/images/sauvegarder2.gif");
2589     //En normal
2590     else surf_bouton[1]=IMG_Load("sdl/images/sauvegarder.gif");
2591     
2592     //Position du bouton à l'écran
2593     position.x=(MESSAGE_LARGEUR-(surf_bouton[0]->w)*2)/3;
2594     position.y=MESSAGE_HAUTEUR-(surf_bouton[0]->h);
2595     //Affichage du bouton
2596     SDL_BlitSurface(surf_bouton[0], NULL, surf_message, &position);
2597     
2598     //Position du bouton à l'écran
2599     position.x=2*(MESSAGE_LARGEUR-(surf_bouton[0]->w))/3;
2600     position.y=MESSAGE_HAUTEUR-(surf_bouton[0]->h);
2601     //Affichage du bouton
2602     SDL_BlitSurface(surf_bouton[1], NULL, surf_message, &position);
2603   }
2604   //S'il s'agit d'un message prison
2605   else if(int_type_message==MESSAGE_PRISON)
2606   {
2607     //Chargement de l'image en surbrillance
2608     if(int_etat==1) surf_bouton[0]=IMG_Load("sdl/images/attendre2.gif");
2609     //En normal
2610     else surf_bouton[0]=IMG_Load("sdl/images/attendre.gif");
2611     //Chargement de l'image en surbrillance
2612     if(int_etat==2) surf_bouton[1]=IMG_Load("sdl/images/payer2.gif");
2613     //En normal
2614     else surf_bouton[1]=IMG_Load("sdl/images/payer.gif");
2615     //Chargement de l'image en surbrillance
2616     if(int_etat==3) surf_bouton[2]=IMG_Load("sdl/images/certificat2.gif");
2617     //En normal
2618     else surf_bouton[2]=IMG_Load("sdl/images/certificat.gif");
2619     
2620     //Position du bouton à l'écran
2621     position.x=30;
2622     position.y=MESSAGE_HAUTEUR-(surf_bouton[0]->h);
2623     //Affichage du bouton
2624     SDL_BlitSurface(surf_bouton[0], NULL, surf_message, &position);
2625     
2626     //Position du bouton à l'écran
2627     position.x=(MESSAGE_LARGEUR-(surf_bouton[2]->w))/2;
2628     position.y=MESSAGE_HAUTEUR-(surf_bouton[2]->h);
2629     //Affichage du bouton
2630     SDL_BlitSurface(surf_bouton[1], NULL, surf_message, &position);
2631     
2632     //Position du bouton à l'écran
2633     position.x=MESSAGE_LARGEUR-30-(surf_bouton[2]->w);
2634     position.y=MESSAGE_HAUTEUR-(surf_bouton[2]->h);
2635     //Affichage du bouton
2636     SDL_BlitSurface(surf_bouton[2], NULL, surf_message, &position);
2637   }
2638   //S'il s'agit d'un message normal
2639   else
2640   {
2641     //Chargement de l'image en surbrillance
2642     if(int_etat==1) surf_bouton[0]=IMG_Load("sdl/images/valider2.gif");
2643     //En normal
2644     else surf_bouton[0]=IMG_Load("sdl/images/valider.gif");
2645     //Position du bouton à l'écran
2646     position.x=(MESSAGE_LARGEUR-(surf_bouton[0]->w))/2;
2647     position.y=MESSAGE_HAUTEUR-(surf_bouton[0]->h);
2648     //Affichage du bouton
2649     SDL_BlitSurface(surf_bouton[0], NULL, surf_message, &position);
2650   }
2651   
2652   //Position du message à l'écran
2653   position.x=POS_X_PLATEAU+CASE_HAUTEUR+(TAILLE_CENTRE-MESSAGE_LARGEUR)/2;
2654   position.y=POS_Y_PLATEAU+CASE_HAUTEUR+(TAILLE_CENTRE-MESSAGE_HAUTEUR)/2;
2655   //Affichage du message à l'écran
2656   SDL_BlitSurface(surf_message, NULL, surf_ecran, &position);
2657   //Mise à jour de l'écran
2658   SDL_Flip(surf_ecran);
2659   
2660   //Libération des surfaces temporaires
2661   SDL_FreeSurface(surf_bouton[0]);
2662   if(int_type_message==MESSAGE_QUITTER || int_type_message==MESSAGE_PRISON) SDL_FreeSurface(surf_bouton[1]);
2663   if(int_type_message==MESSAGE_PRISON) SDL_FreeSurface(surf_bouton[2]);
2664 }
2665 
\end{verbatim}\end{Code}


